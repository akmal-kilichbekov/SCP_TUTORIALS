'use strict';

/* jslint indent: 4 */

var fs = require('fs');
var util = require('util');

var trace = process.env.TRACE;
const Liveness_Ping = require('./liveness-ping');

// initialize with dummy object, will be replaced with instance of Liveness_Ping if --liveness-ping is set.
let liveness_ping = {
  sent: () => {},
  stop: () => {}
};

function writeToStdOut () {
  liveness_ping.sent();
  var str = util.format.apply(null, arguments) + '\n';
  process.stdout.write(str);
}

function writeToStdErr () {
  liveness_ping.sent();
  var str = util.format.apply(null, arguments) + '\n';
  process.stderr.write(str);
}

exports.set_liveness_ping = function (enable_liveness_ping) {
  if (enable_liveness_ping) {
    liveness_ping = new Liveness_Ping();
  }
};

exports.stop_sending_liveness_ping = function () {
  liveness_ping.stop();
};

exports.log = writeToStdOut;

exports.warn = function () {
  var args = arguments;
  args[0] = 'WARNING: ' + args[0];
  writeToStdOut.apply(null, args);
};

exports.logfn = function () {
  var args = arguments;
  return function (cb) {
    writeToStdOut.apply(null, args);
    cb();
  };
};

exports.error = writeToStdErr;

exports.setTrace = function (value) {
  trace = value;
};

const client_private_key_1_regexp = new RegExp('"client_authentication_private_key":.*', 'ig');
const client_private_key_2_regexp = new RegExp('client_authentication_private_key:.*', 'ig');
const client_private_key_3_regexp = new RegExp('key:.*', 'g');
exports.trace = function () {
  if (trace) {
    var str = util.format.apply(null, arguments);
    str = str.replace(/PASSWORD.*/ig, 'p[...]');
    str = str.replace(client_private_key_1_regexp, '"client_authentication_private_key": [..]');
    str = str.replace(client_private_key_2_regexp, 'client_authentication_private_key: [..]');
    str = str.replace(client_private_key_3_regexp, 'key: [..]');
    writeToStdOut(str);
  }
};

var timers = {};

function timerInit (timer) {
  timers[timer] = process.hrtime();
}

function timerDelta (timer) {
  var then = timers[timer];
  var diff = process.hrtime(then);
  if (then || diff) {
    return '(' + (diff[0]) + 's ' + (diff[1] / 1000000).toFixed(0) + 'ms)';
  } else {
    return '';
  }
}

exports.timerInit = timerInit;

exports.timerDelta = timerDelta;

function logTimerInit (timer) {
  var args = Array.prototype.slice.call(arguments, 1);
  timerInit(timer);
  writeToStdOut.apply(null, args);
}

function logTimerDelta (timer) {
  var args = Array.prototype.slice.call(arguments, 1);
  var delta = timerDelta(timer);
  args.push(delta);
  writeToStdOut.apply(null, args);
}

exports.logTimerInit = logTimerInit;

exports.logTimerDelta = logTimerDelta;

exports.logfnTimerInit = function () {
  var args = arguments;
  return function (cb) {
    logTimerInit.apply(undefined, args);
    cb();
  };
};

exports.logfnTimerDelta = function () {
  var args = arguments;
  return function (cb) {
    logTimerDelta.apply(undefined, args);
    cb();
  };
};

var verbose = true;

exports.setVerbose = function (value) {
  verbose = value;
};

exports.logVerbose = function () {
  if (verbose) {
    writeToStdOut.apply(null, arguments);
  }
};

var logFile;

exports.setLogFile = function (filename) {
  logFile = filename;
};

var logMessageId = 0;

exports.nextMessageId = function () {
  return ++logMessageId;
};

exports.logToFile = function (message) {
  if (logFile) {
    fs.appendFileSync(logFile, JSON.stringify(message) + '\n');
  }
};

var sendMessagesToParentProcess = false;

exports.setSendMessagesToParentProcess = function (value) {
  sendMessagesToParentProcess = value;
};

exports.logToParent = function (message) {
  if (sendMessagesToParentProcess) {
    if (process.send) {
      process.send(message);
    }
  }
};
