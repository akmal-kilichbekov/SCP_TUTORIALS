const Pool = require('./Pool')
const Transaction = require('./Transaction')
const TenantManager = require('./TenantManager')
const _options = require('./options')
const resolved = require('./resolved')
const cds = require('../cds')
const { IllegalFunctionArgumentError } = require('../errors')

const MODEL = Symbol.for('model')

/**
 * Service to acquire db connection clients.
 */
class Service {
  /**
   * Creates a Service according to the given pool settings (minimum and maximum number of clients) and client settings
   * (db client type and connection options).
   *
   * @param {String} [datasource] - name of datasource
   * @param {Object} [options] - Pool and Client settings
   * @param {Object} [options.pool] - The min and max pool settings.
   * @param {number} [options.pool.min] - The minimum number of db connection clients.
   * @param {number} [options.pool.max] - The maximum number of db connection clients.
   * @param {number} [options.pool.idleTimeoutMillisForPools] - The time interval in ms until an idle pool is
   * evicted.
   * Default 60000 ms (1 min).
   * @param {number} [options.pool.evictionRunIntervalMillis] - The time interval in ms for an eviction check of idle db
   * clients in a pool.
   * Default 10000 ms (10 s).
   * @param {number} [options.pool.numTestsPerEvictionRun] - The number of db clients to be checked in each eviction run.
   * Defaults to half of options.pool.min, but at least 2.
   * @param {number} [options.pool.softIdleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. Does not evict idle db clients if number of available clients would fall below
   * options.pool.min.
   * Default 30000 ms (30 s).
   * @param {number} [options.pool.idleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. If number of available clients would fall below options.pool.min it evicts this
   * client and creates a new one to meet options.pool.min.
   * Default 480000 ms (8 min).
   * @param {Object} options.kind - The to be used DB client.
   * @param {Object} [options.model] - The to be used model.
   * @param {Object} [options.service] - if options.model, the to be used service name.
   * @param {Object} [options.credentials] - Credentials how to connect with a client
   * @param {string} [options.credentials.host] - Address to the db
   * @param {string} [options.credentials.port] - Port for db
   * @param {string} [options.credentials.user] - Username for authentication
   * @param {string} [options.credentials.password] - Password for authentication
   * @param {boolean} [options.multiTenant] - true, if mt is active
   */
  constructor (datasource, options) {
    this.options = _options(datasource, options)

    if (this.options.multiTenant === true) {
      if (this.options.package) {
        this._enrichOptions = this.options.package.options
      }

      if (!this._tenantManager) {
        this._tenantManager = new TenantManager(this.options)
      }
    }

    if (this.options.package) {
      if (this.options.package.serviceFunctions) {
        Object.defineProperties(this, {
          create: { value: this.options.package.serviceFunctions.create, writable: true },
          read: { value: this.options.package.serviceFunctions.read, writable: true },
          update: { value: this.options.package.serviceFunctions.update, writable: true },
          delete: { value: this.options.package.serviceFunctions.delete, writable: true },
          insert: { value: this.options.package.serviceFunctions.insert, writable: true }
        })
      }

      if (this.options.package.httpFunctions) {
        Object.defineProperties(this, {
          get: { value: this.options.package.httpFunctions.get, writable: true },
          post: { value: this.options.package.httpFunctions.post, writable: true },
          put: { value: this.options.package.httpFunctions.put, writable: true },
          patch: { value: this.options.package.httpFunctions.patch, writable: true },
          delete: { value: this.options.package.httpFunctions.delete, writable: true }
        })
      }

      if (this.options.package.messagingFunctions) {
        Object.defineProperties(this, {
          on: { value: this.options.package.messagingFunctions.on, writable: true },
          emit: { value: this.options.package.messagingFunctions.emit, writable: true },
          removeAllListeners: { value: this.options.package.messagingFunctions.removeAllListeners, writable: true },
          putQueue: { value: this.options.package.messagingFunctions.putQueue, writable: true },
          deleteQueue: { value: this.options.package.messagingFunctions.deleteQueue, writable: true },
          addSubscription: { value: this.options.package.messagingFunctions.addSubscription, writable: true }
        })
        this.on.error = this.options.package.messagingFunctions.onError.bind(this)
        this.on.topic = this.options.package.messagingFunctions.onTopic.bind(this)
        this.emit.to = Object.defineProperties(this, {
          topic: { value: this.options.package.messagingFunctions.emitToTopic, writable: true },
          queue: { value: this.options.package.messagingFunctions.emitToQueue, writable: true }
        })
      }
    }

    this._init()
    this._pools = new Map()

    // Create cache for accessing entities
    Object.defineProperties(this, { _entities: { value: {} } })
  }

  _init () {
    // 1.  Save current functions
    const _acquire = this.acquire
    const _run = this.run
    const _foreach = this.foreach
    const _deploy = this.deploy

    const _create = this.create
    const _read = this.read
    const _update = this.update
    const _delete = this.delete
    const _insert = this.insert

    const _get = this.get
    const _post = this.post
    const _put = this.put
    const _patch = this.patch

    // 2. Load the model asynchronously
    const done = this._loadServiceModel(this.options.model)

      // 4. Remove/Replace placeholders when loaded
      .then(() => {
        delete this.then
        delete this.catch
        this.acquire = _acquire
        this.run = _run
        this.foreach = _foreach
        this.deploy = _deploy

        if (_create) {
          this.create = _create
          this.read = _read
          this.update = _update
          this.delete = _delete
          this.insert = _insert
        }

        if (_get) {
          this.get = _get
          this.post = _post
          this.put = _put
          this.patch = _patch
          this.delete = _delete
        }

        return this
      })

    // 3. Add placeholder methods to defer operations until the model is loaded
    this.then = (resolve, reject) => done.then(resolve).catch(reject)
    this.catch = reject => done.catch(reject)
    this.acquire = (...args) => done.then(() => this.acquire(...args))
    this.run = (...args) => done.then(() => this.run(...args))
    this.foreach = (...args) => done.then(() => this.foreach(...args))
    this.deploy = (...args) => done.then(() => this.deploy(...args))

    if (_create) {
      this.read = (...args) => done.then(() => this.read(...args))
      this.update = (...args) => done.then(() => this.update(...args))
      this.delete = (...args) => done.then(() => this.delete(...args))
      this.insert = (...args) => done.then(() => this.insert(...args))
      this.create = (...args) => done.then(() => this.create(...args))
    }

    if (_get) {
      this.get = (...args) => done.then(() => this.get(...args))
      this.post = (...args) => done.then(() => this.post(...args))
      this.put = (...args) => done.then(() => this.put(...args))
      this.patch = (...args) => done.then(() => this.patch(...args))
      this.delete = (...args) => done.then(() => this.delete(...args))
    }
  }

  _loadServiceModel (model) {
    if (model) {
      return cds.load(model).then(csn => {
        const model = cds.linked(cds.unfold.for.odata(csn))
        this.model = model

        const services = this.model.all('service')

        if (services.length === 1) {
          this.entities = this.model.childrenOf(services[0], child => child.kind === 'entity')
        } else if (this.options.service) {
          this.entities = this.model.childrenOf(
            services.find(srv => srv.name === this.options.service),
            child => child.kind === 'entity'
          )
        } else {
          this.entities = this.model.entities
        }

        if (this.options.credentials) {
          this.options.credentials.reflectedModel = model
        } else {
          this.options.reflectedModel = model
        }
      })
    }

    return Promise.resolve()
  }

  get model () {
    // throw an error unless model is loaded
    const target =
      (this.options.credentials ? this.options.credentials.database : '') || this.options.url || this.options.host || ''

    throw new Error(
      `${this.options.model ? 'Model not yet loaded' : 'No model configured'} for service ${
        this.options.kind
      }: ${target}`
    )
  }

  set model (csn) {
    Object.defineProperty(this, 'model', { writable: true, value: csn })
  }

  // delegate to linked model
  get entities () {
    return this.model.entities
  }

  set entities (entities) {
    Object.defineProperty(this, 'entities', { writable: true, value: entities })
  }

  /**
   * Acquires a db client from the session.
   * @param {Object} [context] - Context object
   * @param {string} [context.user.id] - The user name for the db connection.
   * @param {string} [context.user.locale] - The language identifier.
   * @param {string} [context.attr.token] - Full JWT from (HTTP) request.
   * @param {string} [context.attr.identityZone] - GUID of a tenant.
   * @returns {Promise.<Object>} A promise for the acquired db client.
   */
  async acquire (context = {}) {
    const poolKey = this._getPoolIdentifier(context.attr)

    // Fallback in case of first call, or pool has been invalidated
    let pool = this._pools.get(poolKey) || this._createPool(poolKey)

    // Test connect or instance manager call is not finished yet
    if (pool instanceof Promise) {
      pool = await pool
    }

    return pool.acquire(context, this._getModel(context))
  }

  /**
   * Get the identifier for the pool.
   * @param {string} tenantId
   * @returns {string}
   * @private
   */
  _getPoolIdentifier ({ identityZone } = {}) {
    if (this.options.multiTenant) {
      if (identityZone) {
        return identityZone
      }

      throw new IllegalFunctionArgumentError('tenantId')
    }

    return 'singleTenant'
  }

  _getModel (context) {
    // Hack if deploy is called, then no model must be loaded.
    return this.options.model && this.hasOwnProperty('model') ? this.model : context[MODEL]
  }

  /**
   * Starts or joins an already started transaction for the given context.
   * @param {Object} [context] - Object to which the transaction is assigned. Most frequently it is the req argument
   * in an event handler; in that case the transaction will be automatically. If omitted, a new transaction will be
   * started, which will not be committed and ended automatically.
   * @returns Object
   */
  transaction (context = {}) {
    if (!context._) {
      context._ = {}
    }

    if (!context._.connections) {
      context._.connections = new Map()
    }

    // only one transaction per session in a specific context
    return context._.connections.get(this) || this._createNewTransaction(context)
  }

  /**
   * Provide large binary stream for a given query.
   *
   * @param {string|object} query - SELECT SQL string or SELECT CQN object.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string or as CQN object with placeholders.
   * @param {Object} [context]
   * @returns {Promise} Promise, that resolves with stream if successful or rejects with error if not.
   * Result object can be undefined if no rows obtained.
   */
  stream (query, values, context = {}) {
    return this.acquire(context).then(client => {
      return client.stream(query, values).then(result => {
        return this.release(client).then(() => {
          return result
        })
      })
    })
  }

  /**
   * Getter for TenantManager
   * @returns {TenantManager}
   */
  get tenantManager () {
    return this._tenantManager
  }

  _createNewTransaction (context) {
    const transaction = new Transaction(this, context)
    context._.connections.set(this, transaction)
    return transaction
  }

  _handlePoolEviction (pool) {
    if (pool.noClientsBorrowed) {
      return this._disconnect(pool, pool._name)
    }
  }

  _clearPoolTimeout (pool) {
    if (pool._timeout !== undefined) {
      clearTimeout(pool._timeout)
      delete pool._timeout
    }
  }

  _setPoolTimeout (pool) {
    if (this.options.pool.idleTimeoutMillisForPools > 0) {
      this._clearPoolTimeout(pool)

      pool._timeout = setTimeout(() => {
        this._handlePoolEviction(pool)
      }, this.options.pool.idleTimeoutMillisForPools)
    }
  }

  /**
   * Create a pool instance if a test connect succeeds.
   * @param poolKey
   * @returns {*|Function|Promise<T>}
   * @private
   */
  _createPool (poolKey) {
    const ready = this._getAndCheckCredentials(poolKey)
      .then(options => {
        return this._createPoolInstance(options, poolKey)
      })
      .catch(err => {
        // Remove pool if multitenancy and crash the node instance on purpose otherwise
        if (this.options.multiTenant) {
          this._pools.delete(poolKey)
        } else {
          setImmediate(() => {
            throw err
          })
        }

        // Throw again or other errors will occur until next tic is reached.
        throw err
      })

    this._pools.set(poolKey, ready)

    return ready
  }

  _createPoolInstance (options, poolKey) {
    const pool = new Pool(poolKey, options)
    pool._name = poolKey
    this._pools.set(poolKey, pool)

    return pool
  }

  /**
   * Load credentials from instance manager if needed.
   * Test connect in any case.
   * @param {string} tenantId
   * @returns {Object}
   * @private
   */
  _getAndCheckCredentials (tenantId) {
    if (this.options.multiTenant) {
      return this._tenantManager.get(tenantId).then(credentials => {
        // Get defaults from general options; mostly pool options are relevant
        const options = Object.assign({}, this.options, { kind: this.options.kind })
        options.pool = Object.assign({}, options.pool)
        options.credentials = Object.assign({}, options.credentials, credentials)

        // A client might not provide the "options" function
        if (this._enrichOptions) {
          this._enrichOptions(options)
        }

        return this._testConnection(options)
      })
    }

    return this._testConnection(this.options)
  }

  /**
   * Test the credentials by doing a test connect.
   * @param {Object} options
   * @returns {Promise<Object>}
   * @private
   */
  _testConnection (options) {
    const Client = options.package.Client
    const client = new Client(options.credentials || options)

    return client
      .connect()
      .then(() => {
        return client.end()
      })
      .then(() => {
        return options
      })
  }

  /**
   * Releases a db client to be reused by the session.
   * @param {Client} client - The client that should be released
   * @returns {Promise} A promise for the release of the client
   */
  release (client) {
    return this._destroyRelease('release', client).then(() => {
      // only remove poolKey for successful releases, otherwise .destroy will fail
      delete client._poolKey
    })
  }

  /**
   * Destroys a db client to be recreated by the session.
   * @param {Client} client - The client that should be destroyed
   * @returns {Promise} A promise for the destruction of the client
   */
  destroy (client) {
    const onFinally = () => {
      delete client._poolKey
    }
    return this._destroyRelease('destroy', client).then(onFinally, onFinally)
  }

  _destroyRelease (command, client) {
    const pool = this._getPoolFromClient(client)

    if (!pool) {
      return Promise.reject(new Error('Destroy: Pool not found'))
    }

    this._setPoolTimeout(pool)

    return pool[command](client)
  }

  _getPoolFromClient (client) {
    return this._pools.get(client._poolKey)
  }

  /**
   * Drain the instance of all clients.
   * Allows a graceful shutdown of the complete session instance.
   * @param {string} [tenantId] - GUID of a tenant.
   */
  disconnect (tenantId) {
    if (this._pools.size === 0) {
      return Promise.resolve()
    }

    if (tenantId) {
      const pool = this._pools.get(tenantId)
      return pool ? this._disconnect(pool, tenantId) : Promise.reject(new Error(`No pool for tenantId ${tenantId}`))
    }

    const disconnects = []

    for (const [poolKey, pool] of this._pools) {
      disconnects.push(this._disconnect(pool, poolKey))
    }

    return Promise.all(disconnects)
  }

  _disconnect (pool, poolKey) {
    // Test connect or instance manager call is not finished yet
    if (pool instanceof Promise) {
      return pool.then(() => {
        return this._cleanupPool(this._pools.get(poolKey), poolKey)
      })
    }

    return this._cleanupPool(pool, poolKey)
  }

  _cleanupPool (pool, poolKey) {
    return pool.disconnect().then(() => {
      this._clearPoolTimeout(pool)
      this._pools.delete(poolKey)
    })
  }

  /**
   * Execute CQN or SQL outside of the odata package.
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
   * @param {Object} [context] Event context.
   * @returns {Object} thenable, that resolves with result object (array) if successful or rejects with error if not.
   *
   */
  run (query, values, context = {}) {
    const runs = []
    const promise = this.acquire(context).then(client => {
      let chain = client.run(query, values)

      for (const args of runs) {
        chain = chain.then(() => {
          return client.run(...args).catch(err => {
            throw err
          })
        })
      }

      return chain
        .then(res => {
          return this.release(client).then(() => {
            return res
          })
        })
        .catch(err => {
          return this.release(client).then(() => {
            throw err
          })
        })
    })

    const then = (resolve, reject) => {
      return promise.then(resolve).catch(reject)
    }

    const end = {
      then: then,
      catch: promise.catch
    }

    then.run = (...args) => {
      runs.push(args)
      return end
    }

    return end
  }

  /**
   * Executes the statement and processes the result set one by one.
   * Should be used if huge result sets are expected to process it in a streaming-like fashion
   * instead of materializing the full set in memory before.
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
   * @param {function} cb - synchronous function to process each row of the result set.
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  foreach (query, values, cb) {
    return this.acquire().then(client => {
      return client
        .foreach(query, values, cb)
        .then(() => this.release(client))
        .catch(err => {
          return this.release(client).then(() => {
            throw err
          })
        })
    })
  }

  /**
   * Drops all tables/views and creates them again
   * @param {object} csn the unreflected CSN.
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  deploy (csn) {
    return this.acquire().then(client => {
      return this._load(csn).then(csn => {
        return client
          .deploy(csn)
          .then(() => this.release(client))
          .catch(err => {
            return this.release(client).then(() => {
              throw err
            })
          })
          .then(() => {
            return this.runInit(csn)
          })
      })
    })
  }

  runInit (csn) {
    const { join, sep } = require('path')
    const paths = new Set([join(process.cwd(), 'db')])
    const regxp = new RegExp('^(.*\\' + sep + 'db)(?:$|\\' + sep + ')', 'i')

    for (const file of csn._sources || []) {
      const [, path] = file.match(regxp) || []

      if (path) {
        paths.add(join(path))
      }
    }

    const all = []

    for (const path of paths) {
      all.push(this._runInit(path))
    }

    return Promise.all(all).then(() => {})
  }

  _runInit (givenPath) {
    const init = resolved(givenPath, 'init')

    return (typeof init === 'function' ? init() : init) || Promise.resolve()
  }

  _load (csn, ...args) {
    if (typeof csn === 'string') {
      args.unshift(csn)

      return cds.load(args).then(csn => {
        this.model = cds.linked(csn)
        return csn
      })
    }

    this.model = cds.linked(csn)
    return Promise.resolve(csn)
  }
}

if (process.env.DEBUG) {
  const { stdout } = require('./debug')

  class DebugSession extends Service {
    acquire (...args) {
      stdout('acquire connection')
      return super.acquire(...args)
    }

    release (...args) {
      stdout('release connection')
      return super.release(...args)
    }

    disconnect () {
      stdout('disconnect session')
      return super.disconnect()
    }
  }

  module.exports = DebugSession
} else {
  module.exports = Service
}
