'use strict'

// Low-level utility functions to work with compact CSN.

/**
 * Get utility functions for a given CSN.
 * @param model - (compact) CSN model
 */
function getUtils(model) {
  return {
    getCsnDef,
    isStructured,
    getFinalType,
    getFinalTypeDef,
    isBuiltinType,
    isManagedAssociationElement,
    isAssocOrComposition,
    isAssociation,
    getArtifactDatabaseNameOf,
    getNamespaceOfArtifact,
  };

  /**
   * Create an object to track visited objects identified
   * by a unique sring.
   * @param id - initial entry
   */
  function createVisited(id) {
    let visited = {};
    check(id);
    return { check };

    /**
     * Check if an identififer has already been visited and
     * add it to the list of visited identifiers.
     * @param id - unique identifier
     */
    function check(id) {
      if (!id) return;
      if (visited[id]) {
        throw new Error('Circular dependency');
      }
      visited[id] = true;
    }
  }

  /**
   * Get the CSN definition for an artifact name.
   * @param defName - absolute name of the artifact
   */
  function getCsnDef(defName) {
    if (model.definitions[defName])
      return model.definitions[defName]
    else
      throw new Error(`Nonexistent definition in the model: '${defName}'`);
  }

  /**
   * Returns if an artifact is a structured type
   * or a typedef of a structured type.
   * @param obj - artifact
   */
  function isStructured(obj) {
    return obj.elements ||
      (obj.type && getFinalTypeDef(obj.type).elements);
  }

  /**
   * Resolves typedefs to its final typedef which is returned.
   * If the artifact for typename isn't a typedef, the name itself is returned.
   * @param typeName - absolute name
   */
  function getFinalTypeDef(typeName) {
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    if (!type) {
      return typeName;
    }
    for (let nextType = type; nextType;) {
      type = nextType;
      visited.check(type.type);
      nextType = model.definitions[nextType.type];
    }
    return type;
  }

  /**
   * Resolves typedefs to its final type (name) which is returned.
   * @param typeName - absolute name
   */
  function getFinalType(typeName) {
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    while (type && type.type) {
      typeName = type.type;
      visited.check(typeName);
      type = model.definitions[typeName];
    }
    return typeName;
  }

  function isBuiltinType(typeName) {
    return typeName.startsWith('cds.') && !typeName.startsWith('cds.foundation.');
  }

  // Return true if 'node' is a managed association element
  // TODO: what about elements having a type, which (finally) is an assoc?
  function isManagedAssociationElement(node) {
    return node.target != undefined && node.on == undefined;
  }

  /**
   * Returns if a type is an association or a composition or a typedef
   * to any of them.
   * @param typeName - absolute type name
   */
  function isAssocOrComposition(typeName) {
    if (typeName === 'cds.Association' || typeName === 'cds.Composition')
      return true;
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    while (type) {
      if (type.type === 'cds.Association' || type.type === 'cds.Composition')
        return true;
      visited.check(type.type);
      type = model.definitions[type.type];
    }
    return false;
  }

  /**
   * Returns if a type is an association or a typedef to it.
   * @param typeName - absolute type name
   */
  function isAssociation(typeName) {
    if (typeName === 'cds.Association')
      return true;
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    while (type) {
      if (type.type === 'cds.Association')
        return true;
      visited.check(type.type);
      type = model.definitions[type.type];
    }
    return false;
  }

  // Return the resulting database name for (absolute) 'artifactName', depending on the current naming
  // convention.
  // - For the 'hdbcds' naming convention, this means converting '.' to '::' on
  //   the border between namespace and top-level artifact.
  // - For the 'plain' naming convention, it means converting all '.' to '_' and uppercasing.
  // - For the 'quoted' naming convention, this is just 'artifactName'.
  // No other naming conventions are accepted
  function getArtifactDatabaseNameOf(artifactName, namingConvention, namespace = undefined) {
    if (namingConvention == 'hdbcds') {
      if (namespace) {
        return `${namespace}::${artifactName.substring(namespace.length + 1)}`;
      }
      return artifactName;
    }
    else if (namingConvention == 'plain') {
      return artifactName.replace(/\./g, '_').toUpperCase();
    }
    else if (namingConvention == 'quoted') {
      return artifactName;
    }
    else {
      throw new Error('Unknown naming convention: ' + namingConvention);
    }
  }

  // get the namespace part of a name
  function getNamespaceOfArtifact(name) {
    let lastDotIdx = name.lastIndexOf('.');
    while (model.definitions[name]) {
      lastDotIdx = name.lastIndexOf('.');
      if (lastDotIdx === -1) return undefined;
      name = name.substring(0, lastDotIdx);
    }
    return name;
  }

}

module.exports = {
  getUtils
};
