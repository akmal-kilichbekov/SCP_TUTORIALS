'use strict';

// A "tools" collection of various transformation functions that might be helpful for
// different backends.
// The sibling of model/tranform/TransformUtil.js whixh works with compacted new CSN.

// const alerts = require('../base/alerts');

const { setProp, cloneWithTransformations } = require('../base/model');
const { copyAnnotations } = require('../model/modelUtils');
const { dfilter } = require('./udict');
const { getUtils } = require('../model/csnUtils');

// Return the public functions of this module, with 'model' captured in a closure (for definitions, options etc).
// Use 'pathDelimiter' for flattened names (e.g. of struct elements or foreign key elements).
// 'model' is compacted new style CSN
// TODO: Error and warnings handling with compacted CSN? - currently just throw new Error for everything
// TODO: check the situation with assocs with values. In compacted CSN such elements have only "@Core.Computed": true
function getTransformers(model, pathDelimiter = '_') {
  // const { error, warning, signal } = alerts(model);
  let options = model.options || {};
  const {
    getCsnDef,
    isStructured
  } = getUtils(model);

  return {
    flattenForeignKeys,
    createForeignKeyElement,
    // TODO: is it needed? checkForeignKeys,
    flattenStructuredElement,
    flattenOnCond,
    // TODO: is it needed in compacted CSN? flattenStructStepsInPath,
    checkExposedAssoc,
    toFinalBaseType,
    getServiceName,
    // TODO: is it needed? addImplicitRedirections,
    // TODO: is it needed in compacted CSN?  isAssociationOperand,
    // TODO: is it needed in compacted CSN?  isDollarSelfOperand,
    createExposingProjection,
    createAndAddDraftAdminDataProjection,
    createScalarElement,
    createAssociationElement,
    createAssociationPathComparison,
    createForeignKey,
    addForeignKey,
    addElement,
    copyAndAddElement,
    createAction,
    addAction,
  };

  // For an array `keys` of foreign key infos, return an array in flattened form
  // in one of the two cases:
  // (1) replace all foreign keys that are managed associations themselves by
  // their respective foreign keys, recursively, with names flattened using 
  // pathDelimiter between path components.
  // (2) replace all foreign keys that are structured with their respective flattened form.
  //
  // Note: must be done after struct flattening(flattenStructuredElement method),
  // otherwise we might encounter already generated foreign key fields in types
  // we have already processed.
  function flattenForeignKeys(keys, assocTarget) {
    // (TNT only): Use <assoc><key> instead of <assoc>_key>
    // TODO: is it needed in the new version?
    let fkSeparator = (options.tntFlavor && !options.tntFlavor.skipGeneratedFKsWithout_) ? '' : pathDelimiter;

    let targetArt = getCsnDef(assocTarget);

    // get all the elements from the target that have 'key' identifier
    let targetKeys = dfilter(targetArt.elements, elem => elem.key === true);
    // in case we have explicitly defined FKs
    Object.assign(targetKeys, dfilter(targetArt.elements, (elem, elemName) => {
      if (elem._flatElementNameWithDots) {
        // this is flattened elem -> keys still not flattened, have to check if starts with key ref
        return keys.map(key => key.ref.join('.')).some(keyDotName => elemName.startsWith(keyDotName));
      } else {
        // exact match of the name
        return keys.map(key => key.ref.join('.')).some(keyDotName => keyDotName === elemName);
      }
    }))

    let result = [];

    // this iteration assumes the elements in the tartgetArtifact are flattened
    for (let key of keys) {

      let fKeyName = key.ref.join(fkSeparator);

      // The key is an association - (1)
      if (Object.keys(targetKeys).includes(fKeyName) && targetKeys[fKeyName].type
        && targetKeys[fKeyName].type === 'cds.Association' && targetKeys[fKeyName].target
      ) {
        // as there is no assurance that the target of the target has flattened keys already
        // has to go through both of the associations
        getCsnDef(targetKeys[fKeyName].target); // sanity check if the definition exists
        let flattenTargetFKeys = flattenForeignKeys(targetKeys[fKeyName].keys, targetKeys[fKeyName].target);
        flattenTargetFKeys.forEach(k => result.push({ ref: [`${fKeyName}${fkSeparator}${k.ref.join(fkSeparator)}`] }));
        continue;
      }

      // collect potential flattened keys, which are the counterpart of the current key
      let flattenedKeys = [];
      for (let keyName in targetKeys) {
        if (targetKeys[keyName].viaTransform && keyName.startsWith(fKeyName))
          flattenedKeys.push(keyName);
      }

      // The keys is structured element (2)
      if (flattenedKeys.length) {
        flattenedKeys.forEach(k => result.push({ ref: [k], as: k }));
      } else {
        // Otherwise simply take as it is
        result.push(key);
      }
    }
    return result;
  }

  // (1) Create an artificial foreign key element for association 'assoc' (possibly part
  // of nested struct, i.e. containing dots) in 'artifact', using foreign key info
  // from 'foreignKey'.
  // (2) Inserting it into 'elements' of 'artifact'.
  // (3) Add a property '$generatedFieldName' to the corresponding 'foreignKey' of the assoc.
  //
  // Note that this must happen after struct flattening(flattenStructuredElement) - both fot elements and foreign keys.
  // Return the newly generated foreign key element.
  function createForeignKeyElement(assoc, assocName, foreignKey, artifact) {
    let fkSeparator = pathDelimiter;

    // Assemble foreign key element name from assoc name, '_' and foreign key name/alias
    // let foreignKeyElementName = assocName.replace(/\./g, pathDelimiter) + fkSeparator + foreignKey.ref.join(pathDelimiter);
    let foreignKeyElementName = `${assocName.replace(/\./g, pathDelimiter)}${fkSeparator}${foreignKey.as || foreignKey.ref.join(pathDelimiter)}`;

    // Assemble artificial foreign key element
    let assocTargetDef = getCsnDef(assoc.target);

    let fkArtifact = assocTargetDef.elements[foreignKey.ref.join(pathDelimiter)]; // foreignKey.as ???

    let foreignKeyElement = Object.create(null);

    // Transfer selected type properties from target key element
    // FIXME: There is currently no other way but to treat the annotation '@odata.Type' as a type property.
    for (let prop of ['type', 'length', 'scale', 'precision', 'default', '@odata.Type']) {
      if (fkArtifact[prop]) {
        foreignKeyElement[prop] = fkArtifact[prop];
      }
    }

    copyAnnotations(assoc, foreignKeyElement, true);

    // If the association is non-fkArtifact resp. key, so should be the foreign key field
    for (let prop of ['notNull', 'key']) {
      if (assoc[prop]) {
        foreignKeyElement[prop] = assoc[prop];
      }
    }

    // TODO: check with values. In CSN such elements have only "@Core.Computed": true
    // If the association was a projection or view element (i.e. it has a 'value'), construct a
    // corresponding 'value' for the generated foreign key element
    // FIXME: Can't resolve the corresponding _artifact links because they might not yet be created.
    // We currently live without them.
    // if (assoc.value) {
    //   // TODO: previously, the code directly accessed assoc.value.element, probably set by forHana
    //   let elemName = assoc.value.element || (assoc.value._artifact ? assoc.value._artifact.name.element : '');
    //   let valueForeignKeyElementName = elemName.replace(/\./g, pathDelimiter) + fkSeparator + foreignKey.name.id;
    //   // For the foreign key element, take the same path as for the assoc, just without the last step
    //   let valueForeignKeyElementPath = [];
    //   if (assoc.value.path) {
    //     valueForeignKeyElementPath = cloneWithTransformations(assoc.value.path, {}, true).slice(0, -1);
    //   }
    //   valueForeignKeyElementPath.push({ id: valueForeignKeyElementName });
    //   foreignKeyElement.value = {
    //     path: valueForeignKeyElementPath,
    //     // TODO: keep the following, needed by toSql ?
    //     absolute: assoc.value.absolute || assoc.value._artifact && assoc.value._artifact.name.absolute,
    //     element: valueForeignKeyElementName,
    //     viaTransform: true, // FIXME: Do we still need this?
    //   }
    //   // FIXME: Remove once the compactor no longer renders 'origin'
    //   if (assoc.origin) {
    //     foreignKeyElement.origin = foreignKeyElement.value;
    //   }
    //   // The foreign key element name is calculated if the assoc hasn't been renamed
    //   if (assoc.name.element == assoc.value.element) {
    //     foreignKeyElement.name.calculated = true;
    //   }
    // }

    // Insert artificial element into artifact, with all cross-links (must not exist already)
    if (artifact.elements[foreignKeyElementName]) {
      throw new Error(`Generated foreign key element "${foreignKeyElementName}" for association "${assocName}" conflicts with existing element`);
    }
    artifact.elements[foreignKeyElementName] = foreignKeyElement;

    // Establish the relationship between generated field and association:
    // - generated field has annotation '@odata.foreignKey4'.
    // - foreign key info has 'generatedFieldName'
    foreignKeyElement['@odata.foreignKey4'] = assocName;
    foreignKey.$generatedFieldName = foreignKeyElementName;
    return { [foreignKeyElementName]: foreignKeyElement };
  }

  // For a structured element 'elem', return a dictionary of flattened elements to
  // replace it, flattening names with pathDelimiter's value and propagating all annotations and the
  // type properties 'key', 'notNull', 'virtual', 'masked' to the flattened elements.
  // example input:
  //  { elem: {
  //          key: true,
  //          @foo: true,
  //          elements: 
  //            { a: { type: 'cds.Integer' } },
  //            { b: { 
  //                 elements:
  //                   { b1: type: 'cds.String', length: 42 } } },
  //  } }
  //
  // result:
  //  { elem_a: {
  //          key: true,
  //          @foo: true,
  //          type: 'cds.Integer' },
  //    elem_b_b1: {
  //          key: true,
  //          @foo: true,
  //          type: 'cds.String',
  //          length: 42 }, 
  // }
  function flattenStructuredElement(elem, elemName) {

    // in case the element is of user defined type => take the definition of the type
    let elemType = model.definitions[elem.type];
    // if no elements => check if the element is of user defined structured type
    if (!elem.elements && elem.type && !elem.type.startsWith('cds.')) {
      if (!elemType)
        throw new Error(`Nonexisting type definition: '${elem.type}'`);
      if (!elemType.elements)
        throw new Error(`Expecting element '${elemName}' to be a structured element`);
    }

    let struct = elemType ? elemType.elements : elem.elements;

    // Collect all child elements (recursively) into 'result'
    let result = Object.create(null);
    for (let childName in struct) {
      let childElem = struct[childName];
      if (isStructured(childElem)) {
        // Descend recursively into structured children
        let grandChildElems = flattenStructuredElement(childElem, childName);
        for (let grandChildName in grandChildElems) {
          let flatElemName = elemName + pathDelimiter + grandChildName;
          let flatElem = grandChildElems[grandChildName];
          result[flatElemName] = flatElem;
          // TODO: check with values. In CSN such elements have only "@Core.Computed": true
          // If the original element had a value, construct one for the flattened element
          // if (elem.value) {
          //   createFlattenedValue(flatElem, flatElemName, grandChildName);
          // }
          // Preserve the generated element name as it would have been with 'hdbcds' names
          setProp(flatElem, '_flatElementNameWithDots', elemName + '.' + grandChildName);
          result[flatElemName] = flatElem;
        }
      } else {
        // Primitive child - clone it and restore its cross references
        let flatElemName = elemName + pathDelimiter + childName;
        let flatElem = cloneWithTransformations(childElem, {}, false);
        flatElem.viaTransform = true; // FIXME: This name is not ideal but used elsewhere, too)
        // TODO: check with values. In CSN such elements have only "@Core.Computed": true
        // If the original element had a value, construct one for the flattened element
        // if (elem.value) {
        //   createFlattenedValue(flatElem, flatElemName, childName);
        // }
        // Preserve the generated element name as it would have been with 'hdbcds' names
        setProp(flatElem, '_flatElementNameWithDots', elemName + '.' + childName);
        result[flatElemName] = flatElem;
      }
    }
    // Fix all collected flat elements (names, annotations, properties, origin ..)
    for (let name in result) {
      let flatElem = result[name];
      // Copy annotations from struct (not overwriting, because deep annotations should have precedence)
      copyAnnotations(elem, flatElem, false);
      // Copy selected type properties
      for (let p of ['key', 'notNull', 'virtual', 'masked', 'viaAll']) {
        if (elem[p]) {
          flatElem[p] = elem[p];
        }
      }
    }
    return result;

    // TODO: check with values. In CSN such elements have only "@Core.Computed": true
    // Create a flattened 'value' for flattened element 'flatElem' with full name 'flatElemName',
    // appending 'lastPathStep' to the original elem's value path
    // function createFlattenedValue(flatElem, flatElemName, lastPathStep) {
    //   flatElem.value = {
    //     // TODO: keep absolute/element, needed by toSql ?
    //     absolute: elem.value.absolute,
    //     element: flatElemName,
    //     viaTransform: true,
    //   }
    //   // Just extend 'elem's path by one step, leaving all IDs as they are (will be fixed later by flattenStructStepsInPath)
    //   if (elem.value.path) {
    //     flatElem.value.path = cloneWithTransformations(elem.value.path, {}, true);
    //   }
    //   flatElem.value.path.push({ id: lastPathStep });
    //   // FIXME: Cannot restore value._artifact here because it might not exist yet (projection
    //   // might be processed before entity). We currently live without it.
    //   // FIXME: Remove once the compactor no longer renders 'origin'
    //   flatElem.origin = flatElem.value;
    // }
  }

  // After flattening of elements we need to flatten the on-conditions of
  // unmanaged associations using those newly created elements
  //
  // Examples:
  // Input as: assoc.on: [{ ref: ['a1', 'x'] }, '=', { ref: ['$self', 'x'] }]
  //                              ^^^   ^^^                   ^^^     ^^^
  //                              (1)   (2)                   (3)     (4)
  // (1) is the current association which is a sub element of struct elem 's' ( ... elements: { s: { a1: association to ... }})
  // (2) is non-structured element in the target
  // (3) is '$self' ... clearly
  // (4) is non-structured element in the current scope
  // The flatten on-condition is: [{ ref: ['s_a1', 'x'] }, '=', { ref: ['x'] }]
  //
  // Input as: assoc.on: [{ ref: ['a2', 'x'] }, '=', { ref: ['$self', 's', 'y'] }]
  //                              ^^^   ^^^                   ^^^     ^^^^^^^
  //                              (1)   (2)                   (3)       (4)
  // (1) is the current association which is a sub element of struct elem 's' ( ... elements: { s: { a2: association to ... }})
  // (2) is non-structured element in the target
  // (3) is '$self' ... clearly
  // (4) is structured element in the current scope
  // The flatten on-condition is: [{ ref: ['s_a2', 'x'] }, '=', { ref: ['s_y'] }]
  //
  // Input as: assoc.on: [{ ref: [{ ref: ['a3', 'x'] }, '=', { ref: ['y'] }]
  //                                      ^^^   ^^^                  ^^^
  //                                      (1)   (2)                  (3)
  // (1) is the current association which is a sub element of struct elem 's' ( ... elements: { s: { a3: association to ... }})
  // (2) is non-structured element in the target
  // (3) element from the current nameresolution scope ( .. elements: { s : { y: ... ; a3: association to ... })
  // The flatten on-condition is: [{ ref: ['s_a3', 'x'] }, '=', { ref: ['s_y'] }]
  //
  // Input as: assoc.on: [{ ref: ['a4', 'struct', 'k1'] }, '=', { ref: ['$self', 's', 'struct', 'k2'] }]
  //                              ^^^   ^^^^^^^^^^^^^                    ^^^^     ^^^^^^^^^^^^^^^^^^
  //                              (1)         (2)                        (3)             (4)
  // (1) is the current association which is a sub element of struct elem 's' ( ... elements: { s: { a4: association to ... }})
  // (2) is structured element in the target
  // (3) is '$self' ... clearly
  // (4) is structured element in the current scope
  // The flatten on-condition is: [{ ref: ['s_a4', 'struct_k1'] }, '=', { ref: ['s_struct_k2'] }]
  function flattenOnCond(assoc, assocName, defElements) {
    if (!assoc.on) return; // nothing to do
    let allRefs = assoc.on.filter(elem => typeof elem === 'object' && elem.ref);
    let targetDef = getCsnDef(assoc.target);
    for (let refObj of allRefs) {
      // if reference is just '$self'
      if (refObj.ref.length === 1 && refObj.ref[0] === '$self')
        continue;

      // remove '$self' when first elem in ref and flatten the rest if needed
      if (refObj.ref[0] === '$self') {
        refObj.ref.shift();
        // the rest of the reference should point to an element from the current definition
        let potentialFlattenElem = refObj.ref.join(pathDelimiter);
        if (defElements && defElements[potentialFlattenElem] && defElements[potentialFlattenElem].viaTransform) {
          refObj.ref = [potentialFlattenElem];
        }
        continue;
      }

      // assoc element itself was flatten
      // -> every first step where current assoc is specified needs to be replaced
      if (assoc.viaTransform && assocName.endsWith(`${pathDelimiter}${refObj.ref[0]}`)) {
        refObj.ref.splice(0, 1, assocName);
        // the rest of the reference should point to an element from the target
        let potentialFlattenElem = refObj.ref.slice(1).join(pathDelimiter);
        if (targetDef.elements && targetDef.elements[potentialFlattenElem] && targetDef.elements[potentialFlattenElem].viaTransform) {
          refObj.ref.splice(1, refObj.ref.length - 1, potentialFlattenElem);
        }
      }

      // reference to flattened element in the target
      let flattenRefName = refObj.ref.join(pathDelimiter);
      if (targetDef.elements) {
        // exact match of flatten element name
        if (targetDef.elements[flattenRefName] && targetDef.elements[flattenRefName].viaTransform) {
          refObj.ref = [flattenRefName];
          continue;
        }
        // when element is defined in the current name resolution scope, like
        // entity E {
        //   key x: Integer;
        //       s : {
        //        y : Integer;
        //        a3 : association to E on a3.x = y;
        //       }
        // }
        let potentialFlattenElem = Object.keys(targetDef.elements)
          .find(elemName => elemName.endsWith(`${pathDelimiter}${flattenRefName}`));
        if (potentialFlattenElem) {
          refObj.ref = [potentialFlattenElem];
          continue;
        }
      }
    }
  }

  // Check that exposed associations do not point to non-exposed targets
  function checkExposedAssoc(artName, assocDef, assocName, service) {
    let assocTargetDef = getCsnDef(assocDef.target);
    if (!assocDef._ignore && assocDef.target && assocTargetDef && !assocDef.target.startsWith(service)) {
      // If we have a 'preserved dotted name' ->  a result of flattening -> This scenario is not supported yet
      if (assocDef._flatElementNameWithDots)
        throw new Error(`Redirection for sub elements not supported yet - association "${artName}.${assocName}"`);
      else
        throw new Error(
          `Association "${artName}.${assocName}" must be redirected: Target "${assocDef.target}" is not exposed by service "${service}"`
        );
    }
  }

  // Replace the type of 'node' with its final base type (in contrast to the compiler,
  // also unravel derived enum types, i.e. take the final base type of the enum's base type.
  // Similar with associations and compositions (we probably need a _baseType link)
  function toFinalBaseType(node) {
    // Nothing to do if no type (or if array/struct type)
    if (!node || !node.type) return;
    // ..  or builtin already
    if (node.type && node.type.startsWith('cds.')) return;

    let typeName = node.type;
    let typeDef = getCsnDef(typeName);
    // Nothing to do if type is an array or a struct type
    if (typeDef.items || typeDef.elements) return;
    // if the declared element is an enum, these values are with priority
    if (!node.enum && typeDef.enum)
      Object.assign(node, { enum: typeDef.enum });
    ['type', 'length', 'precision', 'scale', 'target', 'keys'].forEach(
      prop => { if (typeDef[prop]) node[prop] = typeDef[prop]; }
    )
    toFinalBaseType(node);
  }

  function getServiceName(artifactName) {
    for(;;) {
      let idx = artifactName.lastIndexOf('.');
      if (idx == -1) return null;
      artifactName = artifactName.substring(0, idx);
      let artifact = model.definitions[artifactName];
      if (artifact && artifact.kind === 'service') {
        return artifactName;
      }
    }
  }

  // Return a full projection 'projectionId' of artifact 'art' for exposure in 'service'.
  // Add the created projection to the model and complain if artifact already exists.
  // Used by Draft generation
  function createExposingProjection(art, artName, projectionId, service) {
    let projectionAbsoluteName = `${service}.${projectionId}`;
    // If there already is an artifact with this name, this is either the second attempt or a conflict
    let existingProjection = model.definitions[projectionAbsoluteName];
    if (existingProjection) {
      throw new Error(`Cannot generate projection "${projectionAbsoluteName}" because of name conflict with existing artifact "${service.name.absolute}.$projectionId}"`);
    }
    // Create elements matching the artifact's elements
    let elements = Object.create(null);
    for (let elemName in art.elements) {
      let artElem = art.elements[elemName];
      let elem = Object.assign({}, artElem);
      // Transfer xrefs, that are redirected to the projection
      // TODO: shall we remove the transfered elements from the original?
      // if (artElem._xref) {
      //   setProp(elem, '_xref', artElem._xref.filter(xref => xref.user && xref.user._main && xref.user._main._service == service));
      // }
      // FIXME: Remove once the compactor no longer renders 'origin'
      elements[elemName] = elem;
    }
    let query = {
      'SELECT': {
        'from': {
          'ref': [
            artName
          ]
        }
      }
    };
    // Assemble the projection itself and add it into the model
    let projection = {
      'kind': 'entity',
      query,
      elements,
      //'$syntax': 'projection'
    };
    // copy annotations from art to projection
    for (let a of Object.keys(art).filter(x => x.startsWith('@'))) {
      projection[a] = art[a];
    }
    // Sanity check: Can't already be there (checked above)
    if (model.definitions[projectionAbsoluteName]) {
      throw new Error('Duplicate projection: ' + projectionAbsoluteName);
    }
    model.definitions[projectionAbsoluteName] = projection;
    return projection;
  }

  // Create a 'DraftAdministrativeData' projection on entity 'DRAFT.DraftAdministrativeData'
  // in service 'service' and add it to the model.
  function createAndAddDraftAdminDataProjection(service) {
    // Make sure we have a DRAFT.DraftAdministrativeData entity
    let draftAdminDataEntity = model.definitions['DRAFT.DraftAdministrativeData'];
    if (!draftAdminDataEntity) {
      draftAdminDataEntity = createAndAddDraftAdminDataEntity();
      model.definitions['DRAFT.DraftAdministrativeData'] = draftAdminDataEntity;
    }
    // Barf if it is not an entity or not what we expect
    if (draftAdminDataEntity.kind != 'entity' || !draftAdminDataEntity.elements['DraftUUID']) {
      throw new Error(`Generated entity "DRAFT.DraftAdministrativeData" conflicts with existing artifact`);
    }

    // Create a projection within this service
    return createExposingProjection(draftAdminDataEntity, 'DRAFT.DraftAdministrativeData', 'DraftAdministrativeData', service);

    // Create the 'DRAFT.DraftAdministrativeData' entity (unless it already exist)
    // Return the 'DRAFT.DraftAdministrativeData' entity.
    function createAndAddDraftAdminDataEntity() {
      // Create the 'DRAFT.DraftAdministrativeData' entity
      let artifact = {
        kind: 'entity',
        elements: Object.create(null),
      }

      // key DraftUUID : UUID
      let draftUuid = createScalarElement('DraftUUID', 'cds.UUID', true);
      addElement(draftUuid, artifact);

      // CreationDateTime : Timestamp;
      let creationDateTime = createScalarElement('CreationDateTime', 'cds.Timestamp');
      addElement(creationDateTime, artifact);

      // CreatedByUser : String(256);
      let createdByUser = createScalarElement('CreatedByUser', 'cds.String');
      createdByUser['CreatedByUser'].length = 256;
      addElement(createdByUser, artifact);

      // DraftIsCreatedByMe : Boolean;
      let draftIsCreatedByMe = createScalarElement('DraftIsCreatedByMe', 'cds.Boolean');
      addElement(draftIsCreatedByMe, artifact);

      // LastChangeDateTime : Timestamp;
      let lastChangeDateTime = createScalarElement('LastChangeDateTime', 'cds.Timestamp');
      addElement(lastChangeDateTime, artifact);

      // LastChangedByUser : String(256);
      let lastChangedByUser = createScalarElement('LastChangedByUser', 'cds.String');
      lastChangedByUser['LastChangedByUser'].length = 256;
      addElement(lastChangedByUser, artifact);

      // InProcessByUser : String(256);
      let inProcessByUser = createScalarElement('InProcessByUser', 'cds.String');
      inProcessByUser['InProcessByUser'].length = 256;
      addElement(inProcessByUser, artifact);

      // DraftIsProcessedByMe : Boolean;
      let draftIsProcessedByMe = createScalarElement('DraftIsProcessedByMe', 'cds.Boolean');
      addElement(draftIsProcessedByMe, artifact);

      return artifact;
    }
  }

  // Create an artificial scalar element 'elemName' with final type 'typeName'.
  // Make the element a key element if 'isKey' is true.
  // Add a default value 'defaultVal' if supplied
  // example result: { foo: { type: 'cds.Integer', key: true, default: { val: 6 } } }
  //                   ^^^            ^^^^^^^^^       ^^^^                   ^^
  //                 elemName         typeName        isKey               defaultVal   
  function createScalarElement(elemName, typeName, isKey = false, defaultVal = undefined) {
    if (!typeName.startsWith('cds.') && !getCsnDef(typeName)) {
      throw new Error('Expecting valid type name: ' + typeName);
    }
    let result = {
      [elemName]: {
        type: typeName
      }
    };
    if (isKey) {
      result[elemName].key = true
    }
    if (defaultVal !== undefined) {
      result[elemName].default = {
        val: defaultVal,
      }
    }
    return result;
  }

  // Create an articial element 'elemName' of type 'cds.Association',
  // having association target 'target'. If 'isManaged' is true, take all keys
  // of 'target' as foreign keys.
  // e.g. result:
  // { toFoo: {
  //     type: 'cds.Association', target: 'Foo',
  //     keys: [{ ref: ['id'] }]
  // } }
  function createAssociationElement(elemName, target, isManaged = false) {
    let elem = createScalarElement(elemName, 'cds.Association', false, undefined);
    let assoc = elem[elemName];
    assoc.target = target;

    if (isManaged) {
      assoc.keys = [];
      let targetArt = getCsnDef(target);
      for (let keyElemName in targetArt.elements) {
        let keyElem = targetArt.elements[keyElemName];
        if (!keyElem.key) {
          continue;
        }
        let foreignKey = createForeignKey(keyElemName, keyElem);
        addForeignKey(foreignKey, assoc);
      }
    }
    return elem;
  }

  // Create a comparison operation <assoc>.<foreignElem> <op> <elem>.
  // return an array to be spread in an on-condition
  // e.g. [ { ref: ['SiblingEntity','ID'] }, '=', { ref: ['ID'] } ]
  //                 ^^^^^          ^^^      ^^           ^^^
  //                 assoc      foreignElem  op           elem
  function createAssociationPathComparison(assoc, foreignElem, op, elem) {
    return [
      { ref: [assoc, foreignElem] }, op, { ref: [elem] }
    ]
  }

  // Create an artificial foreign key 'keyElemName' for key element 'keyElem'. Note that this
  // only creates a foreign key, not the generated foreign key element.
  // TODO: check the usage of this function's param 'keyElem' ?
  function createForeignKey(keyElemName/*,  keyElem */) {
    return {
      ref: [keyElemName]
      // TODO: do we need these two?
      // calculated: true,
      // $inferred: 'keys',
    }
  }

  // Add foreign key 'foreignKey' to association element 'elem'.
  function addForeignKey(foreignKey, elem) {
    // Sanity checks
    if (!elem.target || !elem.keys) {
      throw new Error('Expecting managed association element with foreign keys');
    }

    // Foreign key must not exist
    if (elem.keys.some(key => JSON.stringify(foreignKey) === JSON.stringify(key)))
      throw new Error(`Key already exists: ${JSON.stringify(foreignKey)}`);

    // Add the foreign key
    elem.keys.push(foreignKey);
  }


  // Add element 'elem' to 'artifact'
  //
  // 'elem' is in form:
  //  { b: { type: 'cds.String' } }
  // 
  // 'artifact' is:
  //  { kind: 'entity', elements: { a: { type: 'cds.Integer' } ... } }
  function addElement(elem, artifact) {
    // Sanity check
    if (!artifact.elements) {
      throw new Error('Expecting artifact with elements: ' + JSON.stringify(artifact));
    }
    let elemName = Object.keys(elem)[0];
    // Element must not exist
    if (artifact.elements[elemName]) {
      throw new Error(
        `"${elemName}": Element name conflicts with existing element`
      );
    }

    // Add the element
    Object.assign(artifact.elements, elem);
  }

  // Make a copy of element 'elem' (e.g. { elem: { type: 'cds.Integer' } })
  // and add it to 'artifact' under the new name 'elemName'.
  // ( e.g. { artifact: { elements: { elemName: { type: 'cds.Integer' } } })
  // Return the newly created element
  // (e.g. { elemName: { type: 'cds.Integer' } })
  function copyAndAddElement(elem, artifact, elemName) {
    if (!artifact.elements) {
      throw new Error('Expected structured artifact');
    }
    // Must not already have such an element
    if (artifact.elements[elemName]) {
      throw new Error(
        `"${elemName}": Element name conflicts with existing element`
      );
    }

    let result = { [elemName]: {} };
    for (let prop in elem)
      result[elemName][prop] = elem[prop];
    Object.assign(artifact.elements, result);
    return result;
  }

  // Create an artificial action 'actionName' with return type artifact 'returnType' optionally with one parameter 'paramName'
  // of type name 'paramTypeName'
  // TODO: returns array of ...
  function createAction(actionName, returnTypeName = undefined, paramName = undefined, paramTypeName = undefined) {
    // Assemble the action
    let result = {
      [actionName]: {
        kind: 'action'
      }
    };

    let action = result[actionName];

    if (returnTypeName) {
      if (!returnTypeName.startsWith('cds.') && !getCsnDef(returnTypeName))
        throw new Error('Expecting valid return type name: ' + returnTypeName);
      action.returns = { type: returnTypeName };
    }

    // Add parameter if provided
    if (paramName && paramTypeName) {
      if (!paramTypeName.startsWith('cds.') && !getCsnDef(paramTypeName))
        throw new Error('Expecting valid parameter type name: ' + paramTypeName);

      action.params = Object.create(null);
      action.params[paramName] = {
        kind: 'param',
        type: paramTypeName
      }
    }

    return result;
  }

  // Add action 'action' to 'artifact'
  // 'action' is in the form of:
  //  { myAction: { kind: 'action', returns ... } }
  //
  //  'artifact' is:
  //  { kind: 'entity', elements: ... }
  function addAction(action, artifact) {
    if (!artifact.actions) {
      artifact.actions = Object.create(null);
    }

    let actionName = Object.keys(action)[0];
    // Element must not exist
    if (artifact.actions[actionName]) {
      // signal(error`"${actionName}": Generated action name conflicts with existing action`);
      // return;
      throw new Error(`"${actionName}": Generated action name conflicts with existing action`);
    }

    // Add the action
    Object.assign(artifact.actions, action);
  }
}

module.exports = {
  // This function retrieves the actual exports
  getTransformers,
};
