const path = require('path');

const Constants = require('./constants');
const FsHelper = require('./helper/fs_helper');
const i18n = require('./i18n/i18n');



class AddHandler {
    constructor(command) {
        this._command = command;

        this.logger = command.logger;
    }

    async stageCopyTemplates(moduleFolder, options) {}
    async stagePostProcessing(moduleFolder, options) {}
    async copySamples(moduleFolder, options) {}

    async checkPrecondition(moduleFolder, options) {
        if (!options.force) {
            this._command.validateDestination(moduleFolder);
        }

        const modulePath = path.join(options.projectRoot, moduleFolder);
        if (await FsHelper.pathExists(modulePath)) {
            const folderContent = await FsHelper.readdir(modulePath);
            if (!options.force && folderContent.length > 0) {
                throw new Error(i18n.t(i18n.command_target_exists, { moduleFolder }));
            }
        }
    }

    async extendCdsrcJson(moduleFolder, buildTaskType, options) {

        const cdsrcJsonPath = path.join(options.projectRoot, Constants.FILE_NAME_CDSRC_JSON);
        if (buildTaskType && await FsHelper.pathExists(cdsrcJsonPath)) {
            const cdsrcJson = await FsHelper.readJSON(cdsrcJsonPath);
            cdsrcJson.build = cdsrcJson.build || {};
            cdsrcJson.build.tasks = cdsrcJson.build.tasks || [];

            const optionsModel = [moduleFolder];
            const existingTasks = [];
            for (let task of cdsrcJson.build.tasks) {
                if (task.src !== moduleFolder) {
                    task.options = task.options || {};
                    task.options.model = task.options.model || [];
                    task.options.model.push(moduleFolder);
                    existingTasks.push(task);

                    optionsModel.push(task.src);
                }
            }

            existingTasks.push({
                for: buildTaskType,
                src: moduleFolder,
                options: {
                    model: optionsModel.sort()
                }
            });

            cdsrcJson.build.tasks = existingTasks;

            await FsHelper.writeJSON(cdsrcJsonPath, cdsrcJson);
        }
    }

}

module.exports = AddHandler;
