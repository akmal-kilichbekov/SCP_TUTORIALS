const path = require('path');

const AddHandler = require('./add');
const Constants = require('./constants');
const ExecHelper = require('./helper/exec_helper');
const FsHelper = require('./helper/fs_helper');
const i18n = require('./i18n/i18n');
const MTAHelper = require('./helper/mta_helper');
const MvnArchetypes = require('./java/mvn_archetypes');
const XmlHelper = require('./helper/xml_helper');



class AddSrvHandler extends AddHandler {
    constructor(addCommand) {
        super(addCommand);
    }

    async checkPrecondition(moduleFolder, options) {
        await super.checkPrecondition(moduleFolder, options);

        let projectOdataVersion = Constants.ODATA_VERSIONS.DEFAULT;
        const packageJsonPath = path.join(options.projectRoot, Constants.FILE_NAME_PACKAGE_JSON);
        if (await FsHelper.pathExists(packageJsonPath)) {
            const packageJson = await FsHelper.readJSON(packageJsonPath);

            if (packageJson.cds && packageJson.cds.odata) {
                projectOdataVersion = packageJson.cds.odata.version || projectOdataVersion;
            }

            if (projectOdataVersion !== Constants.ODATA_VERSIONS[options.odataVersion]) {
                this._command.reportWarning(i18n.t(i18n.add_different_odata_version, {
                    odataVersion: projectOdataVersion,
                    newVersion: Constants.ODATA_VERSIONS[options.odataVersion]
                }), !options.quiet);
            }
        }

        projectOdataVersion = Constants.ODATA_VERSIONS[options.odataVersion] || projectOdataVersion;
        if (options.modules && options.modules[Constants.MODULE_TYPE_SRV]) {
            if (options.srvTechnology === Constants.SRV_TECHNOLOGY_NODEJS && projectOdataVersion !== Constants.ODATA_VERSIONS['odatav4']) {
                this._command.reportWarning(i18n.wrong_odata_version_for_nodejs, options.debug);
                options.odataVersion = 'odatav4';
            }
        }
    }

    async stageCopyTemplates(moduleFolder, options) {
        this._command.reportProgress(
            i18n.t(i18n.add_copying_templates, { moduleFolder: moduleFolder, moduleType: Constants.MODULE_TYPE_SRV }), options.verbose
        );

        const modulePath = path.join(options.projectRoot, moduleFolder);
        await FsHelper.mkdirp(modulePath);

        switch (options.srvTechnology) {
            case Constants.SRV_TECHNOLOGY_JAVA:
                break;

            case Constants.SRV_TECHNOLOGY_NODEJS:
                if (this._command.isWebIDE()) {
                    await FsHelper.copyTemplate('srv/nodejs/common', modulePath, options);
                }
                break;

            default:
                throw new Error(`Invalid srv technology: ${options.srvTechnology} `);
        }
    }

    async copySamples(moduleFolder, options) {

        const dbModule = options.modules[Constants.MODULE_TYPE_DB];

        const modulePath = path.join(options.projectRoot, moduleFolder);
        let relativeDbFolder = path.relative(moduleFolder, dbModule.folder);

        // remove windows back slashes
        relativeDbFolder = relativeDbFolder.replace(/\\/g, '/');
        await FsHelper.copyTemplate('srv/samples', modulePath, { dbModuleFolder: relativeDbFolder });
    }

    async stagePostProcessing(moduleFolder, options) {

        switch (options.srvTechnology) {
            case Constants.SRV_TECHNOLOGY_JAVA:
                this._command.reportProgress(i18n.init_creating_java_srv, options.verbose);

                await this._runMvn(moduleFolder, options);

                this._command.reportProgress(
                    i18n.init_postprocessing_java_srv,
                    options.verbose
                );

                const pomXmlPath = path.join(options.projectRoot, moduleFolder, 'pom.xml');
                await this._patchPomXml(pomXmlPath);
                break;

            case Constants.SRV_TECHNOLOGY_NODEJS:
                const packageJsonPath = path.join(options.projectRoot, moduleFolder, Constants.FILE_NAME_PACKAGE_JSON); // local package.json
                await this._command.updateDependencies(packageJsonPath, options, this.logger);
                await this._extendLocalPackageJson(moduleFolder, options);
                break;

            default:
                throw new Error(`Invalid srv technology: ${options.srvTechnology} `);
        }

        const yamlPath = path.join(options.projectRoot, 'mta.yaml');
        if (await FsHelper.pathExists(yamlPath)) {
            this._command.reportProgress(i18n.t(i18n.init_creating_mta_file, { yamlPath }), options.verbose);
            await MTAHelper.update(
                moduleFolder,
                yamlPath,
                Constants.MODULE_TYPE_SRV,
                options,
                this.logger
            );
        }

        await this._extendGlobalPackageJson(moduleFolder, options);
        await this.extendCdsrcJson(moduleFolder, Constants.TASKS[Constants.MODULE_TYPE_SRV][options.srvTechnology], options);
    }

    async _runMvn(moduleFolder, options) {
        const modulePath = path.join(options.projectRoot, moduleFolder);
        let tempFolder;
        try {
            tempFolder = await FsHelper.createTempFolder('cds-gen-');
            const odataArchetypeCommand = MvnArchetypes.odataArchetypeCommand(
                moduleFolder,
                options.javaPackage,
                options.projectName,
                options.odataVersion,
                options.quiet,
                options.debug
            );

            await ExecHelper.spawnCommand(
                odataArchetypeCommand,
                tempFolder,
                options,
                this.logger
            );

            const mavenResultPath = path.join(tempFolder, `${options.projectName}-${moduleFolder}`);

            // use await otherwise finally would be called and remove folder
            await FsHelper.copy(mavenResultPath, modulePath);
        } finally {
            if (tempFolder) {
                await FsHelper.remove(tempFolder);
            }
        }
    }

    async _patchPomXml(pomXmlPath) {
        if (await FsHelper.pathExists(pomXmlPath)) {
            const pomXml = await FsHelper.readFile(pomXmlPath);

            const pom = await XmlHelper.parse(pomXml);

            const pomPatchPluginXml = await FsHelper.readFile(
                FsHelper.getTemplate('srv/java/patch/pom.plugin.xml')
            );
            const pomPatchPlugin = await XmlHelper.parse(pomPatchPluginXml);

            if (!pom.project.build) {
                pom.project.build = [{}];
            }
            pom.project.build[0].plugins = pomPatchPlugin;


            const pomPatchResourceXml = await FsHelper.readFile(
                FsHelper.getTemplate('srv/java/patch/pom.resource.xml')
            );
            const pomPatchResource = await XmlHelper.parse(pomPatchResourceXml);
            pom.project.build[0].resources = pomPatchResource;


            const pomPatchProfilesXml = await FsHelper.readFile(
                FsHelper.getTemplate('srv/java/patch/pom.profiles.xml')
            );
            const pomPatchProfiles = await XmlHelper.parse(pomPatchProfilesXml);

            if (!pom.project.profiles) {
                pom.project.profiles = [{
                    profile: []
                }];
            }
            pom.project.profiles[0].profile = pom.project.profiles[0].profile.concat(pomPatchProfiles.profiles.profile);


            await FsHelper.writeFile(pomXmlPath, XmlHelper.stringify(pom));
        }
    }

    async _extendLocalPackageJson(moduleFolder, options) {
        const globalPackageJsonPath = path.join(options.projectRoot, Constants.FILE_NAME_PACKAGE_JSON);

        if (await FsHelper.pathExists(globalPackageJsonPath)) {
            const globalPackageJson = await FsHelper.readJSON(globalPackageJsonPath);

            if (globalPackageJson.dependencies && globalPackageJson.dependencies.hdb) {
                const localPackageJsonPath = path.join(options.projectRoot, moduleFolder, Constants.FILE_NAME_PACKAGE_JSON);
                if (await FsHelper.pathExists(localPackageJsonPath)) {
                    const localPackageJson = await FsHelper.readJSON(localPackageJsonPath);
                    localPackageJson.dependencies = localPackageJson.dependencies || {}
                    localPackageJson.dependencies.hdb = globalPackageJson.dependencies.hdb;

                    await FsHelper.writeJSON(localPackageJsonPath, localPackageJson);
                }
            }
        }
    }

    async _extendGlobalPackageJson(moduleFolder, options) { //NOSONAR
        const packageJsonPath = path.join(options.projectRoot, Constants.FILE_NAME_PACKAGE_JSON);

        if (await FsHelper.pathExists(packageJsonPath)) {
            const packageJson = await FsHelper.readJSON(packageJsonPath);

            let packageJsonChanged = false;

            packageJson.files = packageJson.files || [];
            if (!packageJson.files.includes(moduleFolder)) {
                packageJson.files.push(moduleFolder);

                packageJsonChanged = true;
            }

            packageJson.cds = packageJson.cds || {};

            if (options.modules && options.modules[Constants.MODULE_TYPE_SRV]) {
                let version;
                switch (options.srvTechnology) {
                    case Constants.SRV_TECHNOLOGY_JAVA:
                        version = Constants.ODATA_VERSIONS[options.odataVersion] || Constants.ODATA_VERSIONS.DEFAULT;
                        break;

                    case Constants.SRV_TECHNOLOGY_NODEJS:
                        version = Constants.ODATA_VERSIONS['odatav4'];
                        break;

                    default:
                        throw new Error(`Invalid srv technology: ${options.srvTechnology} `);
                }

                packageJson.cds.odata = {
                    version: version
                };

                packageJsonChanged = true;
            }

            if (moduleFolder !== Constants.DEFAULT_MODULE_FOLDER[Constants.MODULE_TYPE_SRV]) {
                packageJson.cds.folders = packageJson.cds.folders || {};

                const typeEntry = packageJson.cds.folders[Constants.MODULE_TYPE_SRV];
                if (!typeEntry) {
                    packageJson.cds.folders[Constants.MODULE_TYPE_SRV] = moduleFolder;
                } else if (typeEntry instanceof String || typeof typeEntry === 'string') {
                    packageJson.cds.folders[Constants.MODULE_TYPE_SRV] = [typeEntry, moduleFolder];
                } else if (Array.isArray(typeEntry)) {
                    packageJson.cds.folders[Constants.MODULE_TYPE_SRV].push(moduleFolder);
                }

                packageJsonChanged = true;
            }

            if (packageJsonChanged) {
                await FsHelper.writeJSON(packageJsonPath, packageJson);
            }
        }
    }
}

module.exports = AddSrvHandler;
