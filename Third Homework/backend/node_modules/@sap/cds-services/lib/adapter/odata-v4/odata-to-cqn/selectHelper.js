const { FeatureNotSupported } = require('../../../errors')
const { getOnCond } = require('@sap/cds-sql').onCond

const isNavigation = pathSegments => {
  return pathSegments.length > 1 && pathSegments[1].getKind().startsWith('NAVIGATION')
}

const addKeysToWhere = (segments, cqn, isDraftEnabled) => {
  if (isNavigation(segments)) {
    return
  }

  const keyPredicates = segments[0].getKeyPredicates()
  const keys = {}

  for (const keyPredicate of keyPredicates) {
    if (isDraftEnabled && keyPredicate.getEdmRef().getName() === 'IsActiveEntity') {
      keys['IsActiveEntity'] = { val: keyPredicate.getText() === 'true' } // value checked by odata-v4
    } else {
      keys[keyPredicate.getEdmRef().getName()] = keyPredicate.getText()
    }
  }

  if (Object.keys(keys).length !== 0) {
    cqn.where(keys)
  }
}

const _entityNameFromSegment = segment => {
  return segment[segment.getKind() === 'ENTITY' ? 'getEntitySet' : 'getNavigationProperty']()
    .getEntityType()
    .getFullQualifiedName()
    .toString()
}

const _keysFromSegment = segment => {
  if (segment.getKeyPredicates().length > 0) {
    const keys = {}

    for (const keyPredicate of segment.getKeyPredicates()) {
      keys[keyPredicate.getEdmRef().getName()] = keyPredicate.getText()
    }

    return keys
  }
}

const _addKeysToWhereIfNeeded = (cqn, keys, tableAlias) => {
  if (keys) {
    for (const key of Object.keys(keys)) {
      cqn.where(`${tableAlias}.${key}`, keys[key])
    }
  }
}

const _addOnCondToWhere = (cqn, entity, tableAlias, identifier, csn) => {
  const onCond = getOnCond(
    csn.definitions[entity.previous].elements[entity.current],
    entity.current,
    csn,
    tableAlias,
    identifier
  )

  const indexOfFirst = typeof onCond[0] === 'string' ? 1 : 0
  const first = onCond[indexOfFirst]
  const second = onCond[indexOfFirst + 2]

  const previousRef = {
    identifier: first.ref[0],
    refname: first.ref[1]
  }
  const currentRef = {
    refname: second.ref[1],
    identifier: second.ref[0]
  }

  cqn.where(...[previousRef, onCond[indexOfFirst + 1], currentRef])
}

const enhanceCqnWithSubSelects = (cqn, pathSegments, csn, SELECT) => {
  let previousCqn, previousEntityName

  // cut last property in path if it existed
  const segments = pathSegments.filter(s => s.getProperty() === null)

  for (let i = 0; i < segments.length; i++) {
    const isLastElement = i === segments.length - 1
    const tableAlias = `T${i}`
    const entityName = _entityNameFromSegment(segments[i])
    const keys = _keysFromSegment(segments[i])
    let currentCqn

    if (isLastElement) {
      cqn._from(entityName, tableAlias)
      _addKeysToWhereIfNeeded(cqn, keys, tableAlias)
    } else {
      currentCqn = SELECT.from(`${entityName} as ${tableAlias}`, [1])
      _addKeysToWhereIfNeeded(currentCqn, keys, tableAlias)
    }

    if (previousCqn) {
      _addOnCondToWhere(
        previousCqn,
        { current: segments[i].getNavigationProperty().getName(), previous: previousEntityName },
        tableAlias,
        `T${i - 1}`,
        csn
      )

      if (isLastElement) {
        cqn.where('exists', previousCqn)
      } else {
        currentCqn.where('exists', previousCqn)
      }
    }

    previousCqn = currentCqn
    previousEntityName = entityName
  }
}

const isPathSupported = (supported, pathSegments) => {
  for (const segment of pathSegments) {
    if (!supported.includes(segment.getKind())) {
      throw new FeatureNotSupported(`Request parameter ${segment.getKind()} is not supported`)
    }
  }
}

module.exports = {
  addKeysToWhere,
  enhanceCqnWithSubSelects,
  isNavigation,
  isPathSupported
}
