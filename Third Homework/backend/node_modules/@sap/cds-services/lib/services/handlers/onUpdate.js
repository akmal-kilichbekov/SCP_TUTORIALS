const {
  messages: { DB_CONNECTION_MISSING }
} = require('../utils/constants')
const getColumns = require('../utils/columns')
const { addDefaultValuesFlat } = require('../../util/dataProcessUtils')
const { getSelectCQN, checkNotNull, filterReadOnly } = require('../utils/handlerUtils')

const _getInsertCQN = context => {
  const insert = context.statements.INSERT.into(context.target)
  insert.entries([context.data])

  return insert
}

const _insertMissing = async context => {
  if (checkNotNull(context)) {
    return
  }
  filterReadOnly(context)
  await context.run(_getInsertCQN(context))

  addDefaultValuesFlat(context.data, context.target)

  return context.data
}

const _containsChanges = context => {
  return Object.keys(context.data).length > 1
}

/**
 * Generic Handler for UPDATE requests.
 * In case of success it returns the updated entry.
 * If the entry to be updated does not exist, a new entry is created.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onUpdate
 */
const onUpdate = () => async context => {
  if (!context.run) {
    context.log.warn(DB_CONNECTION_MISSING)
    return context.data
  }

  const checkExistCQN = getSelectCQN(context, getColumns(context.target, true))
  const result = checkExistCQN ? await context.run(checkExistCQN) : []

  // No key information given, or entry is not available -> create a new one
  if (result.length === 0) {
    return _insertMissing(context)
  }

  // Store for auditing
  context._oldData = result[0]
  filterReadOnly(context)
  // reject with error if query update fails (not authenticated)
  if (_containsChanges(context) && (await context.run(context.query)) === 0) {
    context.reject(403)
    return
  }

  return Object.assign({}, result[0], context.data)
}

module.exports = onUpdate
