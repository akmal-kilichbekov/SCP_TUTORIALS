const { NextCalledBefore } = require('../../errors')

const Base = require('./Base')
const cds = require('../../cds')
const sqliteLocales = ['de', 'fr']

/**
 * Class representation of on middleware.
 * @augments Base
 * @alias module:hooks.On
 */
class On extends Base {
  /**
   * Adds a middleware handler to the set.
   * @param event
   * @param entity
   * @param handler
   * @private
   */
  _addHandler (event, entity, handler) {
    if (this._isWithMode) {
      this._withHandlers.push({ event, entity, handler })
    } else {
      // ensure that finalOn handler is last in the row
      this._handlers.splice(this._handlers.length - 1, 0, { event, entity, handler })
    }
  }

  /**
   * Check if a handler is registered for event and entity. Execute the handler that is registered,
   * with request and response as input parameter to the handler.
   * @param {string} event - name of the event like READ, UPDATE, ...
   * @param {Object} context - Contains request information and utility events like .send(), .error(), ...
   * @param {string} context.target - the unreflected entity
   * @returns {Promise}
   */
  executeHandlerIfListed (event, context) {
    return new Promise((resolve, reject) => {
      this._middleware(event, context, resolve, reject)
    })
  }

  _checkForLocalizedEntity (event, context, handler) {
    if (event === 'READ' && context.target && handler.handler.isDefault && !context.target['@odata.draft.enabled']) {
      let locale = ''
      if (cds.options && cds.options.kind === 'sqlite') {
        const userLocale = context.user.locale
        if (sqliteLocales.includes(userLocale)) {
          locale = `${userLocale}.`
        }
      }
      const localizedEntity = this._model.definitions[`localized.${locale}${context.target.name}`]
      context.target = localizedEntity || context.target
    }
  }

  _middleware (event, context, resolve, reject) {
    const calledFrom = {}
    const length = this._handlers.length

    let i = 0

    // Recursive function, which will work with closures i and length
    const next = (err, calledFromHandler) => {
      // Throw error if next is called twice from same handler
      if (calledFrom[calledFromHandler]) {
        throw new NextCalledBefore()
      }

      calledFrom[calledFromHandler] = true

      // Explicit end of chain by handler
      if (err) {
        reject(err)
        return
      }

      // .reply or .reject has been called
      if (this._replyRejectCalled(context)) {
        return
      }

      let handler

      // Check all registered handlers if registered for this event.
      while (i < length) {
        // Copy count and use to identify
        const count = i
        let nextCalled = false

        const nextOnce = err => {
          nextCalled = true
          return next(err, count)
        }

        handler = this._handlers[i]
        i++

        // We have to catch in order to be able to release the DB client.
        if (this._match(event, context, handler)) {
          const oldTarget = context.target

          try {
            this._measureStartTime(context, handler)

            this._checkForLocalizedEntity(event, context, handler)

            const result = handler.handler(context, nextOnce)

            if (result && result.then) {
              result
                .then(() => {
                  context.target = oldTarget
                  this._measureEndTime(context, handler)
                })
                .catch(err => {
                  context.target = oldTarget
                  reject(err)
                })
            } else {
              context.target = oldTarget
              this._measureEndTime(context, handler)
            }

            this._handleLayerReturn(context, nextOnce, result, resolve, reject, nextCalled)

            return
          } catch (err) {
            // Do not measure performance in case of error
            context.target = oldTarget
            reject(err)
            return
          }
        }
      }
    }

    next(null, -1)
  }

  /**
   * (a)sync code might be in place which can be expressed in various forms.
   * If a return is given, provide convenience.
   * @private
   */
  _handleLayerReturn (context, next, layerReturn, resolve, reject, nextWasCalled) {
    // Promise or equaly behaving thenables.
    if (layerReturn && layerReturn.then) {
      this._handleThanables(context, layerReturn, resolve, reject)
      return
    }

    // CQN means, we should run it
    if (this._isCQN(layerReturn)) {
      this._handleThanables(context, context.run(layerReturn), resolve, reject)
      return
    }

    //  This will break if a user calls next() inside setTimeout without returning a promise (not supported)
    if (layerReturn === undefined && !nextWasCalled && !this._replyRejectCalled(context)) {
      next()
      return
    }

    // A result is returned, that marks the end of the chain
    if (layerReturn !== undefined && typeof layerReturn !== 'function' && !this._replyRejectCalled(context)) {
      resolve(this._handleErrors(context, layerReturn))
    }

    if ('rejected' in context) {
      reject(context.rejected)
      return
    }

    if ('results' in context) {
      resolve(context.results)
    }
  }

  _replyRejectCalled (context) {
    return 'rejected' in context || 'results' in context
  }

  /**
   * The app dev decided to handle async processes on its own.
   * The result should be the end of the chain.
   * @private
   */
  _handleThanables (context, promise, resolve, reject) {
    promise
      .then(result => {
        if ('rejected' in context) {
          throw context.rejected
        }

        resolve(this._handleErrors(context, 'results' in context ? context.results : result))
      })
      .catch(reject)
  }
}

module.exports = On
