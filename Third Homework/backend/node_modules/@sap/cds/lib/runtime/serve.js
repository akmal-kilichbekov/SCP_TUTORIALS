module.exports = cds_serve
const service = require ('./service')
const isIdentifier = (x) => typeof x === 'string' && /^[A-Za-z_$][\w$]*$/.test (x)
const cache = cds_serve.cache = {}

const ProtocolAdapter = {for:(srv, to='odata_v4') => {
  if (srv._adapters) {
    const a = srv._adapters[to];  if (a) return a
  } else {
    Object.defineProperty (srv,'_adapters', {value:{}})
  }
  const adapter4 = service.adapter.for[to]
  if (adapter4)  return srv._adapters[to] = adapter4(srv)
  else throw new Error (`service protocol ${to} is not supported`)
}}

/**
 * Load given model(s) and construct providers for all defined services.
 */
function cds_serve (service_or_model, _options) { // NOSONAR

  if (!isIdentifier(service_or_model)) {
    return cds_serve('all',_options).from(service_or_model)
  }

  const cds = this.serve === cds_serve ? this : global.cds
  const ready = Promise.resolve().then (_loadModel) .then (_constructProviders)
  const providers=[] //> filled in _constructProviders
  const o = Object.assign({}, _options); return {  // fluent API to fill in options subsequently
    from (model) { o.service = service_or_model; o.model = model; return this },
    to (protocol) { if (protocol) { o.to = protocol }  return this },
    at (path) { if (path) { o.at = path }  return this },
    with (impl) { if (impl) { o.with = impl }  return this },
    in (app) { ready.then (()=>_addProviders2(app)); return this },
    then (r,e) { return ready.then (()=> r(_returnProviders()), e) },
    catch (e) { return ready.catch(e) },
  }

  /**
   * Load the given model if it's not already a parsed csn passed in
   */
  function _loadModel(){

    //> cds.serve(...).from('app')
    let model = o.model

    //> cds.serve(...).from(csn)
    if (typeof model === 'object' && !Array.isArray(model)) return model

    //> cds.serve(...)
    if (!model) {
      //> cds.serve(..., {service})  ==>  cds.serve(service) .from (...)
      //> Note: this is for compatibility only; it's not documented anymore
      if (o.service)  model = service_or_model

      //> cds.serve('all')  ==>  cds.serve('all').from('all')
      //> cds.serve(service)  ==>  cds.serve(service).from('all')
      else { model = 'all'; o.service = service_or_model }
    }

    if (model === 'all' || model[0] === 'all') {
      const {app,srv} = cds.env.folders
      model = [ app, srv, 'services', '.' ].find (m => cds.resolve(m))
      if (!model)  throw new Error (`[cds] - \n
        No service models found in current working directory.
        Make sure you call cds.serve in the root of your project.
      `)
    }

    const key = Array.isArray(model) ? model.join(';') : model
    const cached = cache[key]
    if (cached) return cached

    return cache[key] = cds.load (model)
  }

  /**
   * Construct providers for all services defined in the loaded model.
   */
  function _constructProviders (csn, n=0) {

    const external = cds.env.requires
    const chosen = o.service && o.service !== 'all' ? def => def.name.endsWith (o.service) : ()=>true
    o.passport = o.passport || (cds.env.auth && cds.env.auth.passport)

    // prepare and register all services
    cds.reflect(csn) .foreach (service, def => {
      const name = def.name
      if (def['@cds.serve.ignore']  ||  !chosen(def)  ||  external[name])  return
      if ((o.at || o.with) && ++n > 1) throw new Error('You cannot specify `path` or `impl` for multiple services')
      const options = {...o, at: service.path4 (def, o.at) }
      const provider = _asEventEmitter ( //> pull down
        service.for (csn, {service: name, __proto__: options})
      )
      provider.path = options.at
      providers.push (provider)
      cds.services [name] = provider
      //> only possible when ServiceProvider == ServiceClient
      Object.defineProperty (cds.services, name, { configurable:1,
        set:(s)=> Object.defineProperty (cds.services, name, {value:s, writable:1}),
        get:()=> cds.services[name] = service.client.for (name),
      })
    })
    if (providers.length === 0)  throw new Error (`No service models found in ${csn._sources}`)

    // invoke all service impl functions --> in a pass 2 to allow them connect to local services
    _addImpls()

    return providers
  }

  /**
   * Add constructed providers to express app
   */
  function _addProviders2 (app) {
    for (let each of providers) {
      // audit logger to be provided here, current workaround: take it from service
      service.performanceMeasurement(app)
      service.passport(each, app, each._auditLogger, o)
      // add use method to services for backward compatibility
      each.use = app.use
      app.use (each.path+'/webapp/*', (_,res)=> res.status(400).send()) // REVISIT: this is to avoid ugly warnings by Fiori requests --> should go into Fiori protocol adapter
      app.use (each.path, ProtocolAdapter.for (each, o.to))
      cds.emit ('serve', each)
    }
    cds.emit ('served', providers[0].model)
  }

  /**
   * Invoke all provided service implementation functions or classes
   */
  function _addImpls () {
    for (let each of providers) {
      let impl = each._impl = service.impl4 (each.definition, o.with)
      each.impl (impl)
    }
  }

  /**
   * Returns a single picked provider or a map of all constructed providers
   */
  function _returnProviders() {
    let all={}, srv='none'
    for (let each of providers) {
      srv = all[each.name] = _asHandlerFunction (each)
    }
    if (providers.length === 1 && srv.name === o.service) { // NOSONAR
      if (!(srv.name in srv))  Object.assign (srv,all)  // NOSONAR
      return srv
    }
    else return all
  }

  /**
   * Decorates services as handler functions to delegate requests to the default protocol adapter.
   * This supports usages like this:
   * @example
   * const { CatalogService } = cds.serve(...)
   * app.use ('/cats', CatalogService)
   */
  function _asHandlerFunction (srv) {
      const adapter = ProtocolAdapter.for (srv, o.to)
      const fn = (...args) => adapter(...args)
      Object.setPrototypeOf (fn, srv)
      Object.defineProperty (fn, 'name', {value:srv.name})
      return fn
  }

  /**
   * Adds an .emit() function to services, which dispatches events to registered '.on' handlers.
   * This supports usages like this:
   * @example
   * const { CatalogService } = cds.serve(...)
   * CatalogService.on ('some-event', msg => console.log(msg))
   * CatalogService.emit ('some-event', {some:'data'})
   */
  function _asEventEmitter (srv) {
      srv.emit = (event, data) => {
        const subscription = srv._handlers.on._handlers.find (h => h.event === srv.name+'.'+event)
        if (subscription)  return subscription.handler ({event, data})
      }
      return srv
  }

}
