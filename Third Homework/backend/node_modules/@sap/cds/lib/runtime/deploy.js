const DEBUG = /\b(y|all|deploy)\b/.test (process.env.DEBUG) && console.warn // eslint-disable-line
const cds = require('../../lib/cds')

module.exports = function cds_deploy (model) { return {
    async to (db, options) {
        if (typeof db === 'string')  db = await cds.connect.to (db,options)
        if (typeof model === 'string')  model = await cds.load (model)
        else if (Array.isArray(model))  model = await cds.load (model)
        await db.deploy (model)
        await init_from_csv (db,model,options)
        if (!model)  db.model = cds.linked (model)
        return db
    },
    // continue to support cds.deploy() as well...
    then(n,e) { return this.to (cds.session) .then (n,e) },
    catch(e) { return this.to (cds.session) .catch (e) },
}}


const csvs = filename => filename[0] !== '-' && filename.endsWith ('.csv')
const { path, isdir, isfile, readdir, readFile } = cds.utils

function init_from_csv (db,csn,options={}) { // NOSONAR

  const folders = new Set, cwd = process.cwd()
  for (let model of csn._sources) {
    for (let each of [ model+'/../init.js', 'db/init.js' ]) {
        if (isfile (path.resolve(each))) continue
    }
    for (let data of ['/data','/csv']) {
      for (let each of [ model+data, model+'/..'+data ]) {
        let folder = path.resolve (each)
        if (isdir (folder))  folders.add(folder)
      }
    }
  }

  if (folders.size > 0)  return db.acquire() .then (tx => tx.begin()
    .then (()=> Promise.all ([...folders].map (folder => _init (folder,tx))))
    .then (()=> tx.commit())
    .then (()=> db.release (tx))
  )

  function _init (folder, tx) { return new Promise (_done => {
    let n=0; 
    readdir (folder, (e,files) => {
      _error(e) 
      
      const csvFiles = files.filter(csvs)
      if(csvFiles.length < 1) {
        return _done()
      }

      csvFiles.forEach (each => {
        let entity = _entity4 (each.replace(/-/g,'.').slice(0,-4));  if (!entity) {
          DEBUG && DEBUG (` - warning: ${each} not in model`)  // eslint-disable-line
          return _done()
        }
        let file = path.join(folder,each)
        ++n; readFile (file, 'utf8', (e,src)=>{ _error(e)
          options.silent || console.log (` > filling ${entity.name} from ${path.relative(cwd,file)}`)  // eslint-disable-line
          let [ cols, ...rows ] = cds.parse.csv (src)
          let insert = INSERT.into (entity) .columns (cols) .rows (rows) /* global INSERT */
          tx.run (insert) .then (()=> --n || _done())
        })
    })})
  })}

  function _entity4 (name) {
      const entity = csn.definitions [name]
      if (!entity) {
        if (name.endsWith('_texts')) {
            const base = csn.definitions [name.slice(0,-6)]
            if (base)  return _entity4 (base.elements.texts.target)
        }
        return
      }
      if (entity.query) {
        let {SELECT} = entity.query
        if (SELECT && !SELECT.columns && SELECT.from.ref && SELECT.from.ref.length === 1) {
            return csn.definitions [SELECT.from.ref[0]]
        }
      }
      return entity
  }

  function _error(e) {
    if (e)  throw e
  }

}
