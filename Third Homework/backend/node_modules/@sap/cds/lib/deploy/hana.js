module.exports = deploy

const fse = require('fs-extra');
const os = require('os');
const path = require('path');

const { BuildTaskEngine, BuildTaskFactory } = require('../build');
const buildConstants = require('../build/constants');
const cfUtil = require('./cfUtil');
const hdiDeployUtil = require('./hdiDeployUtil');
const { defaultLogger } = require('./logger');
const mtaUtil = require('../utils/mtaUtil');

const UTF_8 = 'utf-8';


async function deploy(model, buildTaskOptions, credentials, undeployWhitelist, hdiOptions = {}, logger = defaultLogger) { // NOSONAR

  _validateEnvironment();

  const models = (typeof model === 'string' ? [model] : model);
  const projectPath = path.resolve(process.cwd());

  buildTaskOptions = buildTaskOptions || {
    root: process.cwd()
  };
  const allTasks = await new BuildTaskFactory(logger).getTasks(buildTaskOptions);
  const hanaTasks = allTasks.filter((task => {
    return task.for === buildConstants.BUILD_TASK_HANA;
  }));

  // full build needed? only hana build task?
  const buildResult = await new BuildTaskEngine(logger).processTasks(hanaTasks, buildTaskOptions);

  // hana or hanatrial, error if neither found
  let serviceName = await _getServiceName(logger);

  const createdHdiContainers = [];
  for (const currentModelFolder of models) {
    const modelName = path.basename(currentModelFolder);

    if (undeployWhitelist) {
      logger.log('[cds.deploy] - Writing undeploy.json');
      await fse.writeJSON(path.join(currentModelFolder, 'undeploy.json'), undeployWhitelist);
    }

    let hdiContainerName = await mtaUtil.getHdiContainerName(projectPath, modelName, logger);

    if (!createdHdiContainers.includes(hdiContainerName)) {
      createdHdiContainers.push(hdiContainerName);

      await cfUtil.createService(serviceName, 'hdi-shared', hdiContainerName, logger);

      let serviceKey;
      if (!credentials) {
        serviceKey = await cfUtil.getServiceKey(hdiContainerName, `${hdiContainerName}-key`, logger);
        if (!serviceKey) {
          throw new Error(`[cds.deploy] - Could not create service key ${hdiContainerName}-key.`);
        }
      } else {
        serviceKey = credentials.hana[0];
      }

      let hasJava;
      for (const task of allTasks) {
        if (task.options && task.options.model && task.options.model.includes(modelName)) {
          switch (task.for) {
            case buildConstants.BUILD_TASK_NODE:
              break;

            case buildConstants.BUILD_TASK_JAVA:
              hasJava = true;
              await _writeConnectionProperties(task.src, serviceKey, logger);
              break;

            default:
              break;
          }
        }
      }

      const defaultEnvJsonPath = path.join(currentModelFolder, 'default-env.json');
      await _writeDefaultEnvJson(defaultEnvJsonPath, modelName, serviceKey, logger);
      await _addToGitignore('.gitignore', 'default-env.json', logger);

      if (hasJava) {
        await _addToGitignore('.gitignore', 'connection.properties', logger);
      }

      await hdiDeployUtil.deploy(currentModelFolder, _getVCAPEntry(modelName, serviceKey), hdiOptions, logger);
    }

    logger.log(`[cds.deploy] - Done.`);
  }

  return { buildResult };
}



async function _getServiceName(logger) {
  let serviceName = 'hana';
  if (!await cfUtil.hasMarketplaceService(serviceName, logger)) {
    serviceName = 'hanatrial';
    if (!await cfUtil.hasMarketplaceService(serviceName, logger)) {
      throw new Error('[cds.deploy] - Services not found');
    }
  }

  return serviceName;
}


async function _writeDefaultEnvJson(defaultEnvJsonPath, modelName, serviceKey, logger) {
  let defaultEnvJson = {};
  if (await fse.pathExists(defaultEnvJsonPath)) {
    defaultEnvJson = await fse.readJSON(defaultEnvJsonPath, UTF_8);
  }

  defaultEnvJson.VCAP_SERVICES = defaultEnvJson.VCAP_SERVICES || {};
  defaultEnvJson.VCAP_SERVICES.hana = defaultEnvJson.VCAP_SERVICES.hana || [];
  defaultEnvJson.VCAP_SERVICES.hana = defaultEnvJson.VCAP_SERVICES.hana.filter(entry => {
    return entry.name !== modelName;
  });

  defaultEnvJson.VCAP_SERVICES.hana.push(_getVCAPEntry(modelName, serviceKey));

  logger.log(`[cds.deploy] - Writing ${defaultEnvJsonPath}`);
  await fse.outputJSON(defaultEnvJsonPath, defaultEnvJson, {
    spaces: 2
  });
}


async function _writeConnectionProperties(javaModulePath, serviceKey, logger) {

  const connectionPropertiesPath = path.join(javaModulePath, 'src', 'main', 'resources', 'connection.properties');

  const content = `#Db connection properties created by cds deploy
schema=${serviceKey.schema}
username=${serviceKey.user}
password=${serviceKey.password}
connectionURL=${serviceKey.url.replace(/=/g, '\\=')}
`;

  logger.log(`[cds.deploy] - Writing ${connectionPropertiesPath}`);
  await fse.outputFile(connectionPropertiesPath, content);
}


async function _addToGitignore(gitIgnorePath, entry, logger) {
  let gitignore = '';
  if (await fse.pathExists(gitIgnorePath)) {
    gitignore = await fse.readFile(gitIgnorePath, UTF_8);
  }

  const entries = gitignore.split(os.EOL);
  if (!entries.includes(entry)) {
    logger.log(`[cds.deploy] - Adding ${entry} to ${gitIgnorePath}`);
    gitignore = gitignore + `\n${entry}\n`;
    await fse.outputFile(gitIgnorePath, gitignore);
  }
}


function _validateEnvironment() {
  if (os.platform() === 'win32' && !process.env.SECUDIR) {
    throw new Error(`[cds.deploy] - In order to use the hdi deployer for Windows you require the SAP CommonCryptoLib.
Please follow https://help.sap.com/viewer/e54136ab6a4a43e6a370265bf0a2d744/4.2.12/en-US/c049e28431ee4e8280cd6f5d1a8937d8.html for further information.`);
  }
}


function _getVCAPEntry(modelName, serviceKey) {
  return {
    name: modelName,
    tags: ['hana'],
    credentials: serviceKey
  };
}
