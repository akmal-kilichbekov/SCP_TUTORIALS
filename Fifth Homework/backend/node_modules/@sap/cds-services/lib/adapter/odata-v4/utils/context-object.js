const {
  Components: {
    ACTION_EXECUTE_HANDLER,
    DATA_DELETE_HANDLER,
    DATA_READ_HANDLER,
    DATA_CREATE_HANDLER,
    DATA_UPDATE_HANDLER
  }
} = require('@sap/odata-server')
const { isCustomOperation } = require('./request')
const odataToCQN = require('../odata-to-cqn/odataToCQN')
const getAnnotatedElements = require('../../utils/getAnnotatedElements')
const getStatements = require('../../utils/getStatements')
const { addDefaultValuesDeep } = require('../../../util/dataProcessUtils')
const { isStreaming } = require('./stream')

const ALLOWED_INFO_PROPERTIES = ['code', 'message', 'numericSeverity', 'longtextUrl']
const EventEmitter = require('events')
const DelayedEmitter = require('../../utils/DelayedEmitter')

const getUserAndAttr = require('../../utils/getUserAndAttr')
const { convertDateTime } = require('../../../services/utils/handlerUtils')
const MODEL = Symbol.for('model')

const _isFunctionInvocation = req =>
  req.getUriInfo().getLastSegment().getFunction || req.getUriInfo().getLastSegment().getFunctionImport

const _getTypeName = edmRef =>
  edmRef.getProperty
    ? edmRef
      .getProperty()
      .getType()
      .getName()
    : edmRef.getType().getName()

const isDraftEntity = target => target['@odata.draft.enabled'] || target['@Common.DraftNode.PreparationAction']

const _proxifyForDraftsName = target => {
  const draftName = `${target.name}_drafts`
  const entityProxyHandler = {
    // TODO: persistence name could be set via annotations or uppercase
    get: (obj, prop) => (prop === 'name' || prop === '@cds.persistence.name' ? draftName : obj[prop])
  }
  return new Proxy(target, entityProxyHandler)
}

const _cancelOrDelete = (target, data) => {
  return (target['@odata.draft.enabled'] || target['@Common.DraftNode.PreparationAction']) &&
    data.IsActiveEntity !== 'true'
    ? 'CANCEL'
    : 'DELETE'
}

/**
 * The key predicates or function parameters will contain the keys and values for this request.
 * Combine all key value pairs into one object.
 * @param parameters
 * @returns {Object}
 * @private
 */
const _getParamData = parameters => {
  const paramData = {}

  for (const segmentParam of parameters) {
    const edmRef = segmentParam.getEdmRef()
    const typeName = _getTypeName(edmRef)

    // Convert any integer type into numeric values.
    paramData[edmRef.getName()] = typeName.startsWith('Int') ? Number(segmentParam.getText()) : segmentParam.getText()
  }

  return paramData
}

const _addForeignKeys = (req, data) => {
  // retrieve keys/values from the path segment representing the navigation source
  const navSourceSegment = req.getUriInfo().getPathSegments()[req.getUriInfo().getPathSegments().length - 2]
  const navSourceKeyValues = _getParamData(navSourceSegment.getKeyPredicates())

  // retrieve relevant foreign key properties of the target entity, including the corresponding source key properties
  const refConstraints = req
    .getUriInfo()
    .getLastSegment()
    .getNavigationProperty()
    .getPartner()
    .getReferentialConstraints()
  let refConstraint

  // set value of foreign key properties as specified in the navigation source segment
  for (const key of Object.keys(navSourceKeyValues)) {
    refConstraint = [...refConstraints].find(r => r[1].constraint.referencedProperty === key)
    // exclude source keys if they cannot be matched (e.g. isActiveEntity in draft scenario)
    if (refConstraint) {
      data[refConstraint[0]] = navSourceKeyValues[key]
    }
  }
}

const _getFunctionParameters = (lastSegment, keyValues) => {
  const functionParameters = lastSegment.getFunctionParameters()
  const paramValues = _getParamData(functionParameters)

  // Working assumption for the case of name collisions: take the entity's key
  for (const key of Object.keys(keyValues)) {
    paramValues[key] = keyValues[key]
  }
  return paramValues
}

/**
 * Get data from odata-v4.
 * READ and DELETE work are retrieved from URL; CREATE and UPDATE from body.
 * For function invocations the URL parameters are set as data.
 * For CREATE and UPDATE annotated columns can be mixed in.
 *
 * @param {string} component - odata-v4 component which processes this request.
 * @param req
 * @param annotatedColumns - in case of insert and update we might have annotated columns for user/now
 * @returns {Object}
 * @private
 */
const _getData = (component, req, annotatedColumns, target) => {
  const segments = req.getUriInfo().getPathSegments()
  const lastSegment = req.getUriInfo().getLastSegment()
  const streaming = isStreaming(segments)
  const keyPredicates = streaming ? segments[segments.length - 2].getKeyPredicates() : lastSegment.getKeyPredicates()
  const keyValues = _getParamData(keyPredicates)

  if (component === DATA_READ_HANDLER && _isFunctionInvocation(req)) {
    return _getFunctionParameters(lastSegment, keyValues)
  }

  if (component === DATA_DELETE_HANDLER || component === DATA_READ_HANDLER) {
    return keyValues
  }

  // Use identifier from URL instead of body
  let data = req.getBody() || {}

  if (streaming && typeof data.pipe === 'function') {
    const dataObj = {}
    dataObj[lastSegment.getProperty().getName()] = data
    data = dataObj
  }

  // Only to be done for post via navigation
  if (component === DATA_CREATE_HANDLER && lastSegment.getKind() === 'NAVIGATION.TO.MANY') {
    _addForeignKeys(req, data)
  }

  for (const key of Object.keys(keyValues)) {
    data[key] = keyValues[key]
  }

  for (const column of annotatedColumns) {
    data[column.name] = column.value
  }

  if (target && (req.getMethod() === 'POST' || req.getMethod() === 'PUT')) {
    addDefaultValuesDeep(data, target)
  }
  return data
}

const _getAnnotatedColumns = (component, target, user) => {
  switch (component) {
    case DATA_CREATE_HANDLER:
      return getAnnotatedElements('insert', target, user)
    case DATA_UPDATE_HANDLER:
      return getAnnotatedElements('update', target, user)
    default:
      return []
  }
}

/**
 * In case of batch request use the applicationData object as base,
 * else create a new object.
 * @param {Object} req - odata-v4 request object.
 * @param {Object} res - odata-v4 response object.
 * @return {Object}
 * @private
 */
const _getUnderscore = (req, res) => {
  let _ = req.getBatchApplicationData()

  if (_) {
    // If batched, and first event of the batch, add indicator, to reuse the same db client.
    if (_.doNotFinishTransaction === undefined) {
      _.doNotFinishTransaction = true
    }

    // In case of $batch avoid side effects across requests
    if (_.infos) {
      delete _.infos
    }

    if (_.errors) {
      delete _.errors
    }
  }

  // Not batched, create object, that can be shared later on and will hold channel specifc details in any case.
  if (!_) {
    _ = {}
  }

  _.odataReq = req
  _.odataRes = res

  // Give the app developer access to the original (express) request object
  if (!_.req) {
    _.req = req.getIncomingRequest()
  }

  return _
}

/**
 * Gets the name of the service entity targeted by the given navigation path.
 * Undefined in case of a function or action import.
 * @param {Service} service
 * @param {Array} pathSegments - The path segments of a uri.
 * @returns {string} - The name of the navigation target entity.
 * @private
 */
const _getTargetEntityName = (service, pathSegments) => {
  if (isCustomOperation(pathSegments, false)) {
    return undefined
  }

  let navSegmentName
  let entityName = `${service.name}.${pathSegments[0].getEntitySet().getName()}`

  for (const navSegment of pathSegments.filter(segment => segment.getNavigationProperty() !== null)) {
    navSegmentName = navSegment.getNavigationProperty().getName()
    entityName =
      navSegmentName === 'DraftAdministrativeData'
        ? service.entities[navSegmentName].name
        : service.model.definitions[entityName].elements[navSegmentName].target
  }

  return entityName
}

const _newOrCreate = target => {
  return target['@odata.draft.enabled'] || target['@Common.DraftNode.PreparationAction'] ? 'NEW' : 'CREATE'
}

const patchOrUodate = target => {
  return target['@odata.draft.enabled'] || target['@Common.DraftNode.PreparationAction'] ? 'PATCH' : 'UPDATE'
}

const _readOrOperation = (pathSegments, target) => {
  if (isCustomOperation(pathSegments)) {
    const invokedFunction = pathSegments[pathSegments.length - 1].getFunction()
    return target ? invokedFunction.getName() : invokedFunction.getFullQualifiedName().toString()
  }
  return 'READ'
}

const _definedNameOrEdit = (target, pathSegments, service) => {
  const lastSegment = pathSegments[pathSegments.length - 1].getAction().getName()

  if (target) {
    return lastSegment === 'draftEdit' ? 'EDIT' : lastSegment
  }

  return `${service.name}.${lastSegment}`
}

const _getEvent = ({ component, pathSegments, target, data, service }) => {
  switch (component) {
    case DATA_CREATE_HANDLER:
      return _newOrCreate(target)
    case DATA_UPDATE_HANDLER:
      return patchOrUodate(target)
    case DATA_DELETE_HANDLER:
      return _cancelOrDelete(target, data)
    case DATA_READ_HANDLER:
      return _readOrOperation(pathSegments, target)
    case ACTION_EXECUTE_HANDLER:
      return _definedNameOrEdit(target, pathSegments, service)
  }
}

/**
 * Normalization is needed because only certain properties are allowed in an info message.
 * As well js errors cannot be JSON.stringified later on.
 */
const _normalizeInfoMessage = info => {
  if (typeof info === 'string') {
    return { message: info }
  }

  const infoObj = {}

  for (const property of Object.getOwnPropertyNames(info)) {
    if (ALLOWED_INFO_PROPERTIES.includes(property)) {
      infoObj[property] = info[property]
    }
  }

  return infoObj
}

const getContextObject = (component, service, req, res, noProxyTarget = false) => {
  const pathSegments = req.getUriInfo().getPathSegments()

  const definitions = service.model.definitions
  const _target = definitions[_getTargetEntityName(service, pathSegments)]
  const _ = _getUnderscore(req, res)
  const { user, attr } = getUserAndAttr(_, service)

  const annotatedColumns = _getAnnotatedColumns(component, _target, user)
  const data = _getData(component, req, annotatedColumns, _target)

  const target =
    !noProxyTarget && _target && isDraftEntity(_target) && data.IsActiveEntity !== 'true'
      ? _proxifyForDraftsName(_target)
      : _target

  const event = _getEvent({ component, pathSegments, target, data, service })
  const incomingRequest = req.getIncomingRequest()
  const performanceMeasurement = incomingRequest.performanceMeasurement
  const dynatrace = incomingRequest.dynatrace

  const context = {
    user,
    attr,
    data,
    target,
    event,
    get query () {
      const query = odataToCQN(isCustomOperation(pathSegments) || component, service, context, req)
      Object.defineProperty(context, 'query', { value: query, writable: true })
      return query
    },
    set query (value) {
      Object.defineProperty(context, 'query', { value: value, writable: true })
    },
    get statements () {
      const statements = getStatements(service)

      Object.defineProperty(context, 'statements', { value: statements })

      return statements
    },
    info: info => {
      context._.infos = context._.infos || []
      const infoObj = _normalizeInfoMessage(info)
      context._.infos.push(infoObj)

      return infoObj
    },
    _
  }

  // Supporting legacy data services, where the connect does not include a model definition.
  Object.defineProperty(context, MODEL, { value: service.model })

  const atomicityGroupId = req.getAtomicityGroupId()

  if (atomicityGroupId) {
    Reflect.setPrototypeOf(context, DelayedEmitter.prototype)
    context.setStore(context._.eventEmitterOfAtomicityGroup.get(atomicityGroupId))
  } else {
    Reflect.setPrototypeOf(context, EventEmitter.prototype)
  }

  if (context.target) {
    convertDateTime(context.data, context.target.elements)
  }

  if (performanceMeasurement) {
    context.performanceMeasurement = performanceMeasurement
  }

  if (dynatrace) {
    context.dynatrace = dynatrace
  }

  return context
}

module.exports = getContextObject
