const getStatements = require('../../utils/getStatements')
const restToCqn = require('../rest-to-cqn')
const getAnnotatedElements = require('../../utils/getAnnotatedElements')
const { getKeyValuePair } = require('./key-value-utils')
const { addDefaultValuesDeep } = require('../../../util/dataProcessUtils')
const EventEmitter = require('events')
const getUserAndAttr = require('../../utils/getUserAndAttr')
const { convertDateTime } = require('../../../services/utils/handlerUtils')
const MODEL = Symbol.for('model')

const _isCustomOperation = element => {
  return element.kind === 'action' || element.kind === 'function'
}

const _fillKeyValues = (keyValues, data) => {
  for (const key of Object.keys(keyValues)) {
    data[key] = keyValues[key]
  }
}

const _fillAnnotatedValues = (annotatedColumns, data) => {
  for (const column of annotatedColumns) {
    data[column.name] = column.value
  }
}

/**
 * Get data from odata-v4.
 * READ and DELETE work are retrieved from URL; CREATE and UPDATE from body.
 * For function invocations the URL parameters are set as data.
 * For CREATE and UPDATE annotated columns can be mixed in.
 *
 * @param {string} component - odata-v4 component which processes this request.
 * @param req
 * @param annotatedColumns - in case of insert and update we might have annotated columns for user/now
 * @returns {Object}
 * @private
 */
const _getData = ({ method, segments }, annotatedColumns, target, req) => {
  // TODO: what to do by reading collections
  const keyValues = method === 'CREATE' ? {} : getKeyValuePair(target, segments[1])

  if (method === 'READ' || method === 'DELETE') {
    return keyValues
  }

  const data = req.body || {}
  const dataArray = Array.isArray(data) ? data : [data]

  for (const data of dataArray) {
    _fillKeyValues(keyValues, data)
    _fillAnnotatedValues(annotatedColumns, data)
  }

  if (target && (req.method === 'POST' || req.method === 'PUT')) {
    addDefaultValuesDeep(dataArray, target)
  }

  return data
}

const _getAnnotatedColumns = (method, context) => {
  switch (method) {
    case 'CREATE':
      return getAnnotatedElements('insert', context.target)
    case 'UPDATE':
      return getAnnotatedElements('update', context.target)
    default:
      return []
  }
}

const _getEvent = ({ customOperation, method, segments }, service) => {
  switch (method) {
    case 'UPDATE':
    case 'DELETE':
      return method
    case 'CREATE':
    case 'READ':
      if (customOperation) {
        const lastSegment = segments[segments.length - 1]
        return customOperation.startsWith('unbound') ? `${service.name}.${lastSegment.name}` : lastSegment.name
      }
      return method
  }
}

const getContextObject = (service, parsedUrl, req, res) => {
  const _ = { req, res }
  const { user, attr } = getUserAndAttr(_, service)
  const event = _getEvent(parsedUrl, service)

  let target

  // TODO: replace with generic solution, target is either the first segment (no associations) or undefined for custom operations
  if (!_isCustomOperation(parsedUrl.segments[0])) {
    target = parsedUrl.segments[0]
  }

  const errors = []

  const context = {
    user,
    attr,
    event,
    errors,
    get data () {
      let data
      if (_isCustomOperation(parsedUrl.segments[parsedUrl.segments.length - 1])) {
        // data = parsedUrl.params || _validatedBodyValues(req.body, parsedUrl, this) || {}
        data = parsedUrl.params || req.body || {}
      } else {
        const annotatedColumns = _getAnnotatedColumns(parsedUrl.method, this)
        data = _getData(parsedUrl, annotatedColumns, this.target, req)
      }
      Object.defineProperty(context, 'data', { value: data })
      return data
    },
    get query () {
      const query = restToCqn(service, context, parsedUrl)

      Object.defineProperty(context, 'query', { value: query })
      return query
    },
    target,
    get statements () {
      const statements = getStatements(service)

      Object.defineProperty(context, 'statements', { value: statements })

      return statements
    },
    _
  }

  // Supporting legacy data services, where the connect does not include a model definition.
  Object.defineProperty(context, MODEL, { value: service.model })

  if (context.target) {
    convertDateTime(context.data, context.target.elements)
  }
  if (req.performanceMeasurement) {
    context.performanceMeasurement = req.performanceMeasurement
  }
  if (req.dynatrace) {
    context.dynatrace = req.dynatrace
  }

  Reflect.setPrototypeOf(context, EventEmitter.prototype)
  return context
}

module.exports = getContextObject
