'use strict';
/* eslint max-statements-per-line:off */
const { setProp } = require('../base/model');

function validateOptions(_options)
{
  if(!_options.isV2 && !_options.isV4)
  {
    // csn2edm expects "version" to be a top-level property of options
    // set to 'v4' as default, override with value from incoming options
    // (here version comes inside "toOdata")
    const options = Object.assign({ version: 'v4'}, _options);
    if (options.toOdata && options.toOdata.version)
      options.version = options.toOdata.version;

    const v2 = options.version.match(/v2/i) != undefined;
    const v4 = options.version.match(/v4/i) != undefined;

    options.v = [v2, v4];

    if(options.v.filter(v=>v).length != 1)
      throw Error(`Please debug me: EDM V2:${v2}, V4:${v4}`);

    options.isV2 = function() { return this.v[0] == true; }
    options.isV4 = function() { return this.v[1] == true; }
    return options;
  }
  else
    return _options;
}

// returns intersection of two arrays
function intersect(a,b)
{
  return [...new Set(a)].filter(x => new Set(b).has(x));
}

// Call func(art, name) for each artifact 'art' with name 'name' in 'dictionary' that returns true for 'filter(art)'
function foreach(dictionary, filter, func) {
  if (dictionary != undefined) {
    for (let name in dictionary) {
      if (dictionary[name] && filter(dictionary[name])) {
        func(dictionary[name], name);
      }
    }
  }
}

// Call func(art, name) for each artifact 'art' with name 'name' in 'dictionary'
function forAll(dictionary, func) {
  foreach(dictionary, ()=>true, func);
}

// true if _containerEntity is unequal to artifact name (non-recursive containment association)
//      or if artifact belongs to an artificial parameter entity
function isContainee(artifact) {
  // if _containerEntity is present, it is guarranteed that it has at least one entry
  return (artifact._containerEntity && (artifact._containerEntity.length > 1 || artifact._containerEntity[0] != artifact.name));
}

// Return true if 'artifact' has an association type
function isAssociation(artifact) {
  return (artifact.type == "cds.Association" || artifact.type == "Association") &&  artifact.target != undefined;
  //return artifact.target != undefined;
}

function isComposition(artifact) {
  return (artifact.type == "cds.Composition" || artifact.type == "Composition") &&
    artifact.target != undefined;
}

function isAssociationOrComposition(artifact)
{
  return isAssociation(artifact) || isComposition(artifact);
}

function isManagedAssociation(artifact)
{
  return isAssociation(artifact) && artifact.onCond == undefined && artifact.on == undefined;
}

// Return true if the association 'assoc' has cardinality 'to-many' 
function isToMany(assoc) {
  if (!assoc.cardinality) {
    return false;
  }
  // Different representations possible: array or targetMax property
  let targetMax = assoc.cardinality[1] ||assoc.cardinality.max;
  if (!targetMax) {
    return false;
  }
  return targetMax == '*' || Number(targetMax) > 1;
}

function isEntityOrView(artifact)
{
  return artifact.kind == 'entity' || artifact.kind == 'view';
}

function isParameterizedEntityOrView(artifact) {
  return isEntityOrView(artifact) && artifact.params;
}

// Return true if 'artifact' is a real structured type (not an entity)
function isStructuredType(artifact) {
  return isStructuredArtifact(artifact) && !isEntityOrView(artifact);
}

// Return true if 'artifact' is structured (i.e. has elements, like a structured type or an entity)
function isStructuredArtifact(artifact) {
  // FIXME: No derived types etc yet
  return (artifact.items && artifact.items.elements || artifact.elements);
}

function isDerivedType(artifact)
{
  return artifact.kind == 'type' && !isStructuredType(artifact);
}

function isActionOrFunction(artifact)
{
  return artifact.kind == 'action' || artifact.kind == 'function';
}

// Initialize 'model' in place for odata-preprocessing. Return a service from 'model' or undefined if there is none.
// FIXME: Should move to some more ODATA-specific location 
function initializeModel(model, options, signal, warning) 
{
  if(options == undefined)
    throw Error('Please debug me: initializeModel must be invoked with options');
  
  // make sure options are complete
  options = validateOptions(options);

    // First attach names to all definitions in the model
  forAll(model.definitions, (a, n) => {
    a.name = n;
  });

  foreach(model.definitions, isActionOrFunction, a => {
    forAll(a.params, (p,n) => {
      p.name = n;
    })
  });

  let service;
  // Fetch service object
  foreach(model.definitions, a => a.kind == 'service', a => { 
    service = a; });

  // Initialize entities with parameters (add Parameter entity)
  foreach(model.definitions, isParameterizedEntityOrView, initializeParameterizedEntityOrView);
  // Initialize structures
  foreach(model.definitions, isStructuredArtifact, initializeStructure);
  // Initialize associations
  foreach(model.definitions, isStructuredArtifact, initializeAssociation);

  foreach(model.definitions, isStructuredArtifact, initializeConstraints);
  return service;

  function initializeParameterizedEntityOrView(entityCsn, entityName) {
    const deepCopy = require('../base/deepCopy.js');

    // Naming rules for aggregated views with parameters
    // Parameters: EntityType <ViewName>Parameters, EntitySet <ViewName>
    //             with NavigationProperty "Results" pointing to the entity set of type <ViewName>Result
    // Result:     EntityType <ViewName>Result, EntitySet <ViewName>Results

    // Naming rules for non aggregated views with parameters
    // Parameters: EntityType <ViewName>Parameters, EntitySet <ViewName>
    //             with NavigationProperty "Set" pointing to the entity set of type <ViewName>Type
    // Result:     EntityType <ViewName>Type, EntitySet <ViewName>Set
    //             Backlink Navigation Property "Parameters" to <ViewName>Parameters

    // this code can be extended for aggregated views
    let parameterEntityName = entityName + 'Parameters';
    let parameterEntitySetName = entityName;
    let originalEntityName = entityName + 'Type';
    let originalEntitySetName = entityName + 'Set';
    let parameterToOriginalAssocName = 'Set';
    let backlinkAssocName = 'Parameters';
    let hasBacklink = true;

    // Construct the parameter entity
    let parameterCsn = { name: parameterEntityName, setName: parameterEntitySetName, kind: 'entity', isParamEntity:true, elements: Object.create(null) };

    // propagate containment information, if containment is recursive, use parameterCsn.name as _containerEntity
    if(entityCsn._containerEntity) {
      parameterCsn._containerEntity = [];
      for(let c of entityCsn._containerEntity) {
        parameterCsn._containerEntity.push((c==entityCsn.name)?parameterCsn.name:c);
      }
    }
    entityCsn._containerEntity = [ parameterCsn ];

    forAll(entityCsn.params, (p,n) => {
      let elt = deepCopy(p);
      elt.name = n;
      delete elt.kind;
      elt.key = true; // params become primary key in parameter entity
      parameterCsn.elements[n] = elt;
    });

    // add assoc to result set, FIXME: is the cardinality correct?
    parameterCsn.elements[parameterToOriginalAssocName] = {
      '@odata.contained': true,
      name: parameterToOriginalAssocName,
      target: entityCsn,
      type: 'cds.Association',
      _partnerCsn: [],
      cardinality: { src: 1, min: 0, max: '*' }
    };
    model.definitions[parameterCsn.name] = parameterCsn;


    // modify the original parameter entity with backlink and new name
    entityCsn.name = originalEntityName;
    entityCsn.setName = originalEntitySetName;

    // add backlink association
    if(hasBacklink) {
      entityCsn.elements[backlinkAssocName] = {
        name: backlinkAssocName,
        target: parameterCsn,
        type: 'cds.Association',
        _partnerCsn: [],
        on: [ { ref: [ 'Parameters', 'Set' ] }, '=', { ref: [ '$self' ] } ]
      };
    }
  }
  // Initialize structured artifact (type or entity) 'struct' by doing the
  // following:
  // - attach attributes 'name', 'Name' to elements (FIXME: We currently really require both 'Name' and 'name'!)
  // - create a property 'keys' with all its primary key elements
  // - optionally add the magic ValueList association
  // - call 'initializeAssociation' for each element that has an association type
  // - attach attribute 'name' to all actions and their parameters.  
  function initializeStructure(struct) {

    const appSpecificLateCsnTranformations = require('./appSpecificLateCsnTranformations');

    let keys = Object.create(null);
    let validFrom = [], validKey = [];

    // Iterate all struct elements
    forAll(struct.elements, (element, elementName) => {
      // Attach name and Name (Name is used in function ForeignKey4(assoc))
      element.name = element.Name = elementName;
      setProp(element, '_parent', struct);

      if(element['@cds.valid.key']) {
        validKey.push(element);
      }
      if(element['@cds.valid.from']) {
        validFrom.push(element);
      }
      // Collect keys
      if (element.key) {
        keys[elementName] = element;
      }

      if(options.tntFlavor && !options.tntFlavor.skipValueListMagic)
        addValueListAssociation(element, struct);

      appSpecificLateCsnTranformations.atElement(options, element, struct);
    });

    // if artifact has a cds.valid.key make this the only primary key and
    // add all @cds.valid.from + original primary keys as alternate keys
    // @Core.AlternateKeys: [{ Key: [ { Name: 'slID', Alias: 'slID' }, { Name: 'validFrom', Alias: 'validFrom'} ] }]

    if(validKey.length) {
      let altKeys = [{ Key: [] }];
      forAll(keys, (k, kn) => {
        altKeys[0].Key.push( { Name: kn, Alias: kn } );
        delete k.key;
      });
      validFrom.forEach(e => {
        altKeys[0].Key.push( { Name: e.name, Alias: e.name } );
      });
      if(struct['@Core.AlternateKeys'] === undefined) {
        struct['@Core.AlternateKeys'] = altKeys;
      }      keys = Object.create(null);
      validKey.forEach(e => {
        e.key = true;
        keys[e.name] = e;
      });
    }
    else {
      validFrom.forEach(e => {
        e.key = true;
        keys[e.name] = e;
      });
    }
    setProp(struct, '_EntitySetAttributes', Object.create(null));

    appSpecificLateCsnTranformations.atStructure(options, struct);

    struct['key'] = keys;
    initializeActions(struct.actions);

  }

  function initializeActions(actions)
  {
    // Attach name to actions and their parameters
    forAll(actions, (a, n) => {
      a.name = n;
      forAll(a.params, (a, n) => {
        a.name = n;
        if(options.tntFlavor && !options.tntFlavor.skipValueListMagic)
        {
          let valueListType = a['@Common.ValueList.type'];
          if(valueListType && valueListType['#'] || valueListType === 'fixed')
            a['@sap:value.list'] = 'fixed-values';
        }
      });
    });
  }

  // Resolve the association type of 'element' in 'struct' by doing the following:
  // - collect the foreign key elements for the target into attribute 'elements'
  // - replace the String attribute 'target' by the actual target artifact
  function initializeAssociation(struct)
  {
    foreach(struct.elements, isAssociationOrComposition, element => {
      if (element._ignore) return;
      if(typeof element.target === "string") {
        element.target = model.definitions[element.target];

        // in case this is a forward assoc, store the backlink partneres here, _partnerCsn.length > 1 => error
        element._partnerCsn = [];
        // if the target is a containee AND target has parameters, redirect
        // target to <Type>Parameters entity (see initializeParameterizedEntityOrView() above)
        // Preserve the original target for backlinks (getReferentialConstraints()
        // for details
        if(element.target._containerEntity && element.target.params) {
          element.originalTarget = element.target;
          element.target = element.target._containerEntity[0];
        }
      }

      //forward annotations from managed association element to its foreign keys
      if(element.keys) {
        for(let fk of element.keys) {
          forAll(element, (attr, attrName) => {
            if(attrName[0] == '@')
              struct.elements[fk.$generatedFieldName][attrName] = attr;
          });
        }
      }
    });
  }

  function initializeConstraints(struct) {
    foreach(struct.elements, isAssociationOrComposition, element => {
      if (element._ignore) return;
      element._constraints = getReferentialConstraints(element, signal, warning);

      // only in V2 we must set the target cardinality of the backlink to the forward:
      if(element._constraints._originAssocCsn && element.cardinality && element.cardinality.max) {
        if(element._constraints._originAssocCsn.cardinality) {
          if(element._constraints._originAssocCsn.cardinality.src) {
            let srcMult = (element._constraints._originAssocCsn.cardinality.src == 1) ? '0..1' : '*';
            let newMult = (element.cardinality.max > 1) ? '*' : '0..1';
            if(options.isV2() && srcMult != newMult) {
              // Association 'E_toF': Multiplicity of Role='E' defined to '*', conflicting with target multiplicity '0..1' from 
              signal(warning`Source cardinality "${element._constraints._originAssocCsn.cardinality.src}" of "${element._constraints._originAssocCsn._parent.name}/${element._constraints._originAssocCsn.name}" conflicts with target cardinality "${element.cardinality.max}" of association "${element._parent.name}/${element.name}"`);
            }
          }
          else {
            element._constraints._originAssocCsn.cardinality.src = element.cardinality.max;
          }
        }
        else {
          element._constraints._originAssocCsn.cardinality = { src: element.cardinality.max };
        }
      }
    });

  }

  /*
  If an element is annotated with @Common.ValueList.entity, an additional
  unmanaged association is added to the entity type named 'to_' + element.name.
  The value of @Common.ValueList.entity is the association target.
  */
  function addValueListAssociation(element, struct)
  {
    let valueListType = element['@Common.ValueList.type'];
    if(valueListType)
    {
      let valueListEntityName = element['@Common.ValueList.entity'] || element.name;
      let valueListEntity = model.definitions[service.name + '.' + valueListEntityName];

      // TODO: throw error if not found?
      if(valueListEntity)
      {
        if((valueListType['#'] || valueListType) === 'fixed')
          element['@sap.value-list'] = "fixed-values";

        let assocName = 'to_' + element.name;

        let pkn;
        // last key wins, must be only one key, error?
        foreach(valueListEntity.elements, e => e.key,
          (key, keyName) => { pkn = keyName; });

        // add the value list association as new element into struct.elements
        let assoc = {
          name: assocName,
          target: valueListEntity,
          type: 'cds.Association',
          _partnerCsn: [],
          on: [ { ref: [ element.name ] },"=", { ref: [ assocName, pkn ] } ]
        }
        setProp(assoc, '_parent', struct);
        struct.elements[assocName] = assoc;
      }
    }
  }
}

function getReferentialConstraints(assocCsn, signal, warning)
{
  let result = { constraints: Object.create(null), selfs: [], termCount: 0 };

  if(assocCsn.on)
  {
    // fill constraint array with [prop, depProp]
    getExpressionArguments(assocCsn.on);

    // for all $self conditions, fill constraints of partner (if any)
    let isBacklink = result.selfs.length == 1 && result.termCount == 1;

    /* example for originalTarget:
    entity E (with parameters) { 
      ... keys and all the stuff ...
      toE: association to E;
      back: association to E on back.toE = $self
    }
    toE target 'E' is redirected to 'EParameters' (must be as the new parameter list is required)
    back target 'E' is also redirected to 'EParameters' (otherwise backlink would fail)
    ON Condition back.toE => parter=toE cannot be resolved in EParameters, originalTarget 'E' is
    required for that
    */
    result.selfs.forEach(partner => {
      let originAssocCsn = assocCsn.target.elements[partner];
      if(originAssocCsn == undefined && assocCsn.originalTarget)
        originAssocCsn = assocCsn.originalTarget.elements[partner];
      if(originAssocCsn === undefined) {
        signal(warning`Cannot resolve backlink to ${assocCsn.target.name}/${partner}" from "${assocCsn._parent.name}/${assocCsn.name}"`);
      }
      else
      {
        if(originAssocCsn.target != assocCsn._parent) {
          signal(warning`"${assocCsn._parent.name}/${assocCsn.name}" references "${originAssocCsn._parent.name}/${partner}" in $self ON condition with target "${originAssocCsn.target.name}"`);
        }

        // let originAssocCsn = assocCsn.target.elements[partner] || assocCsn.originalTarget.elements[partner];
        if(isAssociationOrComposition(originAssocCsn)) {
          // if the assoc is marked as primary key, add all its foreign keys as constraint
          // as they are primary keys of the other entity as well
          if(!assocCsn.target.isParamEntity && originAssocCsn.key) {
            if(originAssocCsn.keys) {
              for(let fk of originAssocCsn.keys) {
                let c = [ fk.ref[0], fk.$generatedFieldName ];
                result.constraints[c] = c;
              }
            }
          }

          // Mark this association as backlink if $self appears exactly once
          // to surpress edm:Association generation in V2 mode
          if(isBacklink) {
            // use first backlink as partner
            if(originAssocCsn._partnerCsn.length == 0) {
              result._originAssocCsn = originAssocCsn;
            }
            else {
              isBacklink = false;
            }

            // collect all backlinks at forward association
            originAssocCsn._partnerCsn.push(assocCsn);
          }
        }
        else {
          /*
            entity E  {
              key id : Integer;
              toMe: associaton to E on toMe.id = $self; };
            */
          throw Error('Backlink association element is not an association or composition: "' + originAssocCsn.name);
        }
      }
    });

    if(!assocCsn.target.isParamEntity) {
      // Header is composed of Items => Cds.Composition: Header is principal => use header's primary keys
      let dependentEntity = assocCsn._parent;
      let principalEntity = assocCsn.target;
      if(assocCsn.type == 'cds.Composition') {
        principalEntity = assocCsn._parent;
        dependentEntity = assocCsn.target;
        // Swap the constraint elements to be correct on Composition [principal, dependent] => [dependent, principal]
        Object.keys(result.constraints).forEach(cn => {
          result.constraints[cn] = [ result.constraints[cn][1], result.constraints[cn][0] ] } );
      }
      // Remove all arget elements that are not key in the principal entity
      // and all elements that annotated with '@cds.api.ignore'
      foreach(result.constraints,
        c => {
          let fk = dependentEntity.elements[c[0]];
          let pk = principalEntity.key[c[1]];
          return !(pk && fk && !(pk['@cds.api.ignore'] || fk['@cds.api.ignore']));
        },
        (c, cn) => { delete result.constraints[cn]; } );
    }
  }
  // Handle managed association, a managed composition is treated as association
  else
  {
    // If FK is key in target => constraint
    // Don't consider primary key associations (fks become keys on the source entity) as
    // this would impose a constraint against the target.
    // Filter out all elements that annotated with '@cds.api.ignore'

    // FIXME: If path is something structured, perform a path resolution (or use augmented CSN)
    if(!assocCsn.target.isParamEntity && assocCsn.keys) {
      for(let fk of assocCsn.keys) {
        let realFk = assocCsn._parent.elements[fk.$generatedFieldName];
        let pk = assocCsn.target.elements[fk.ref[0]].key;
        if(pk && !(pk['@cds.api.ignore'] || realFk['@cds.api.ignore']))
        {
          let c = [ fk.$generatedFieldName, fk.ref[0] ];
          result.constraints[c] = c;
        }
      }
    }
  }

  // If this association points to a redirected Parameter EntityType, do not calculate any constraints,
  // continue with multiplicity
  if(assocCsn.target.isParamEntity)
  {
    result.constraints = Object.create(null);
  }
  return result;

  // nested functions
  function getExpressionArguments(expr)
  {
    let allowedTokens = [ '=', 'and', '(', ')' ];
    if(expr && Array.isArray(expr))
      // if some returns true, this term is not usable as a constraint term
      if(!expr.some(isNotAConstraintTerm))
        expr.forEach(fillConstraints)

    // return true if token is not one of '=', 'and', '(', ')' or object
    function isNotAConstraintTerm(tok)
    {
      if(tok.xpr)
        return tok.xpr.some(isNotAConstraintTerm);
      if(Array.isArray(tok))
        return tok.some(isNotAConstraintTerm);
      return !(typeof tok === 'object' && tok != null || allowedTokens.includes(tok));
    }

    // fill constraints object with [dependent, principal] pairs and collect all forward assocs for $self terms
    function fillConstraints(arg, pos)
    {
      if(arg.xpr)
        arg.xpr.map(fillConstraints);
      else if(pos > 0 && pos < expr.length)
      {
        let lhs = expr[pos-1];
        let rhs = expr[pos+1];
        if(['='].includes(arg))
        {
          result.termCount++;
          if(lhs.ref && rhs.ref) // ref is a path
          {
            lhs = lhs.ref;
            rhs = rhs.ref;
            // if exactly one operand starts with the prefix then this is potentially a constraint
            if((lhs[0] === assocCsn.name && rhs[0] !== assocCsn.name) ||
              (lhs[0] !== assocCsn.name && rhs[0] === assocCsn.name))
            {
              // order is always [ property, referencedProperty ]
              //backlink         [ self, assocName ]
              let c;
              if(lhs[0] === assocCsn.name)
                c = [rhs[0], lhs[1]];
              else
                c = [lhs[0], rhs[1]];

              // do we have a $self id?
              // if so, store partner in selfs array
              if(c[0] === '$self')
                result.selfs.push(c[1]);
              else
                result.constraints[c] = c;
            }
          }
        }
      }
    }
  }
}

function determineMultiplicity(csn)
{
  /*
    =>  SRC Cardinality
    CDS   => EDM
    ------------
    undef =>  '*' // CDS default mapping for associations
    1     => 0..1 // CDS default mapping for compositions
    n     => '*'
    n/a   => 1   // not expressable
    *     => *

    => TGT Cardinality
    CDS   => EDM
    ------------
    undef      => 0..1 // CDS default mapping for associations
    0..1       => 0..1
    1          => 0..1
    1 not null => 1  (targetMin=1 is set by transform/toOdata.js)
    1..1       => 1
    0..m       => '*' // CDS default mapping for compositions
    m          => '*'
    1..n       => '*'
    n..m       => '*'
    *          => '*'
  */

  /* new csn:
  src, min, max
  */

  if(!csn.cardinality)
    csn.cardinality = Object.create(null);

  // set missing defaults
  // A managed composition is treated as an ordinary association
  /*
  if(csn.type == 'cds.Composition' && csn.on || csn.onCond) {
    if(!csn.cardinality.src)
      csn.cardinality.src = '1';
    if(!csn.cardinality.min)
      csn.cardinality.min = 0;
    if(!csn.cardinality.max)
      csn.cardinality.max = '*';
  }
  else */
  {
    if(!csn.cardinality.src)
      csn.cardinality.src = '*';
    if(!csn.cardinality.min)
      csn.cardinality.min = 0;
    if(!csn.cardinality.max)
      csn.cardinality.max = 1;
  }

  let  srcCardinality = (csn.cardinality.src == 1) ? '0..1' : '*';
  let  tgtCardinality = (csn.cardinality.max > 1 || csn.cardinality.max == '*') ? '*' :
                          (csn.cardinality.min == 1) ? '1' : '0..1';

  return [srcCardinality, tgtCardinality];
}

function mapCdsToEdmType(cdsType, isV2=false, isMediaType=false)
{
  let edmType = {
    'cds.String': 'Edm.String',
    'cds.LargeString': 'Edm.String',
    'cds.Boolean': 'Edm.Boolean',
    'cds.Integer': 'Edm.Int32',
    'cds.Integer16': 'Edm.Int16',
    'cds.Integer32': 'Edm.Int32',
    'cds.Integer64': 'Edm.Int64',
    'cds.Float': 'Edm.Single',
    'cds.Double': 'Edm.Double',
    'cds.Decimal': 'Edm.Decimal',
    'cds.DecimalFloat': 'Edm.Decimal',
    'cds.Date': 'Edm.Date',
    'cds.Time': 'Edm.TimeOfDay',
    'cds.DateTime':  (isV2 && false) ? 'Edm.DateTime': 'Edm.DateTimeOffset', // eslint-disable-line no-constant-condition
    'cds.Timestamp': (isV2 && false) ? 'Edm.DateTime' : 'Edm.DateTimeOffset', // eslint-disable-line no-constant-condition
    'cds.UTCTimestamp': 'Edm.DateTimeOffset',
    'cds.Binary': 'Edm.Binary',
    'cds.LargeBinary': 'Edm.Binary',
    'cds.UUID': 'Edm.Guid',
    /* unused but EDM defined
    Edm.Geography
    Edm.GeographyPoint
    Edm.GeographyLineString
    Edm.GeographyPolygon
    Edm.GeographyMultiPoint
    Edm.GeographyMultiLineString
    Edm.GeographyMultiPolygon
    Edm.GeographyCollection
    Edm.Geometry
    Edm.GeometryPoint
    Edm.GeometryLineString
    Edm.GeometryPolygon
    Edm.GeometryMultiPoint
    Edm.GeometryMultiLineString
    Edm.GeometryMultiPolygon
    Edm.GeometryCollection
    */
  }[cdsType];
  if (edmType == undefined)
    throw Error('No edm type found for ' + cdsType);
  if(isV2)
  {
    if (edmType == 'Edm.Date') 
      edmType = 'Edm.DateTime';
    if (edmType == 'Edm.TimeOfDay')
      edmType = 'Edm.Time';
  }
  else // isV4
  {
    // CDXCORE-CDXCORE-173
    if(isMediaType)
      edmType = 'Edm.Stream';
  }
  return edmType;
}

function addTypeFacets(node, csn)
{
  if (csn.length)
    node.MaxLength = csn.length;
  if (csn.scale)
    node.Scale = csn.scale;
  if (csn.precision)
    node.Precision = csn.precision;
  // Unicode/SRID unused today
  if(csn.unicode)
    node.Unicode = csn.unicode;
  if(csn.srid)
    node.SRID = csn.srid;
}

module.exports = {
  validateOptions,
  intersect,
  foreach,
  forAll,
  isContainee,
  isAssociation,
  isManagedAssociation,
  isComposition,
  isAssociationOrComposition,
  isToMany,
  isEntityOrView,
  isStructuredType,
  isStructuredArtifact,
  isDerivedType,
  isActionOrFunction,
  initializeModel,
  getReferentialConstraints,
  determineMultiplicity,
  mapCdsToEdmType,
  addTypeFacets
}
