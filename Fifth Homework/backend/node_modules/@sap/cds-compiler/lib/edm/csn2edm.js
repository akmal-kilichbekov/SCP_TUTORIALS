'use strict';

/* eslint max-lines:off */
/* eslint max-statements-per-line:off */

let NAVPROP_TRENNER = '_'         // possibly overruled for TNT below
let VALUELIST_NAVPROP_PREFIX = '' // possibly overruled for TNT below

const glue = require('./glue.js')
const Edm = require('./edm.js');
const translate = require('./annotations/genericTranslation.js');
const alerts = require('../base/alerts');
const { handleMessages } = require('../base/messages');
const { setProp } = require('../base/model');

/*
OData V2 spec 06/01/2017 PDF version is available from here:
https://msdn.microsoft.com/en-us/library/dd541474.aspx
*/

/* invocation:
  metadata: csn2edm(forOdata, { version:'v2' })
*/


module.exports = function csn2edm(csn, serviceName, _options) {

  const { error, warning, signal } = alerts(csn);

  const options = glue.validateOptions(_options);

  let v = options.v;

  // get us a fresh model copy that we can work with
  let model = JSON.parse(JSON.stringify(csn));
  model.messages = csn.messages;

  // Remove from the model all definitions that do not belong to the specified service
  // TODO maybe this can be combined with initializeModel
  if (serviceName) {
    let allDefinitions = model.definitions;
    let namesNotInService = Object.keys(allDefinitions).filter(n => !n.startsWith(serviceName + '.') && n != serviceName);
    for (let name of namesNotInService) {
      delete model.definitions[name];
    }
  }

  let serviceCsn = glue.initializeModel(model, options, signal, warning);
  if(serviceCsn === undefined)
    signal(error`No Service found in model`);

  let navigationProperties = [];

  function baseName(str, del) { let l = str.lastIndexOf(del);   // eslint-disable-line no-unused-vars
    return (l >= 0) ? str.slice(l+del.length, str.length) : str; }

  // if we have a real alias take it, otherwise use basename of service
  // let alias = serviceCsn.alias || baseName(baseName(serviceCsn.name, '::'), '.');

  // FIXME: UI5 cannot deal with spec conforming simpleid alias names
  let alias = serviceCsn.name;

  let Schema = new Edm.Schema(v, serviceCsn.name, undefined /* unset alias */);

  // now namespace and alias are used to create the fullQualified(name)
  const namespace = serviceCsn.name + '.'
  alias += '.'

  let service = new Edm.DataServices(v, Schema);
  let edm = new Edm(v, service);

  /* create the entitytypes and sets
     Do not create an entity set if:
        V4 containment: _containerEntity is set and not equal with the artifact name
        Entity starts with 'localized.' or ends with '_localized'
  */
  glue.foreach(model.definitions,
    a => glue.isEntityOrView(a) && !a.abstract,
    a => createEntityTypeAndSet(a, !( options.isV4() && (glue.isContainee(a)) ) )
  );

  // create unbound actions/functions
  glue.foreach(model.definitions, glue.isActionOrFunction,
               (options.isV4()) ? createActionV4 : createActionV2);

  // create the complex types
  glue.foreach(model.definitions, glue.isStructuredType, createComplexType);

  if(options.isV4())
  {
    glue.foreach(model.definitions,
      artifact => glue.isDerivedType(artifact) &&
      !glue.isAssociationOrComposition(artifact),
        createTypeDefinition);
  }

  // fetch all exising children names in a map
  let NamesInSchemaXRef = Schema._children.reduce((acc, cur) => {
    if(acc[cur.Name] === undefined) {
      acc[cur.Name] = [ cur ]; 
    } else {
      acc[cur.Name].push(cur);
    }
    return acc;
  }, {} );

  navigationProperties.forEach(np => {
    /*
    if(np._csn._partnerCsn.length > 1) {
      signal(warning`NavigationProperty "${np._csn._parent.name}/${np.Name}" has more then one partner: ${np._csn._partnerCsn.map(csn=>'"'+csn._parent.name+'/'+csn.Name+'"').join(', ')}`);
    }
    */
    if(options.isV4()) {
      // V4: No referential constraints for Containment Relationships
      if(!np.isContainment() && !np.isToMany())
        np.addReferentialConstraintNodes();
    }
    else
      addAssociation(np);
  });

  createAnnotations(edm);

  for(let name in NamesInSchemaXRef) {
    if(NamesInSchemaXRef[name].length > 1) {
      signal(error`Duplicate name "${name}" in Namespace "${Schema.Namespace}"`);
    }
  }
  if(Schema._ec._children.length == 0)
    signal(error`EntityContainer must contain at least one EntitySet`);

  // Throw up if we have errors
  handleMessages(model, options);
  return edm

  //--------------------------------------------------------------------------------
  // embedded functions
  //--------------------------------------------------------------------------------

  function createEntityTypeAndSet(entityCsn, createEntitySet=true)
  {
  // EntityType attributes are: Name, BaseType, Abstract, OpenType, HasStream
    // Sub Elements are: Key, Property, NavigationProperty

    let EntityTypeName = entityCsn.name.replace(namespace, '');
    let EntitySetName = (entityCsn.setName || entityCsn.name).replace(namespace, '');

    let [ properties, hasStream ] = createProperties(entityCsn);

    if(properties.length === 0) {
      signal(error`EntityType "${serviceName}/${EntityTypeName}" has no properties`);
    }
    // construct EntityType attributes
    let attributes = { Name : EntityTypeName };

    // CDXCORE-CDXCORE-173
    if(options.isV2() && hasStream)
      attributes['m:HasStream'] = hasStream;

    Schema.append(new Edm.EntityType(v, attributes, properties, entityCsn));

    if (createEntitySet)
    {
      let entitySet = new Edm.EntitySet(v, { Name: EntitySetName, EntityType: fullQualified(EntityTypeName) }, entityCsn);

      // V4: Create NavigationPropertyBinding in EntitySet if NavigationProperty is not a Containment
      if(options.isV4())
        properties.filter(np => np instanceof Edm.NavigationProperty && !np.isContainment()).
          forEach(np => entitySet.append(np.createNavigationPropertyBinding(namespace)));

      Schema._ec.append(entitySet);
    }

    // put actions behind entity types in Schema/EntityContainer
    glue.forAll(entityCsn.actions, (a, n) => {
      (options.isV4()) ? createActionV4(a, n, entityCsn)
                       : createActionV2(a, n, entityCsn)
    });
  }

  // add bound/unbound actions/functions for V4
  function createActionV4(actionCsn, name, entityCsn=undefined)
  {
    let iAmAnAction = actionCsn.kind == "action";

    let actionName = actionCsn.name.replace(namespace, '');

    let attributes = { Name: actionName, IsBound : false };

    if(!iAmAnAction)
      attributes.IsComposable = false;

    let actionNode = (iAmAnAction) ? new Edm.Action(v, attributes)
                                   : new Edm.FunctionDefinition(v, attributes);

    // bpName is eventually used later for EntitySetPath
    let bpNameAnno = actionCsn['@cds.odata.bindingparameter.name'];
    let bpName = bpNameAnno !== undefined ? (bpNameAnno['='] || bpNameAnno) : 'in';

    if(entityCsn != undefined)
    {
      actionNode.IsBound = true;
      let bpType = actionCsn['@cds.odata.bindingparameter.collection'] ? 
        'Collection('+fullQualified(entityCsn.name)+')' : fullQualified(entityCsn.name);
      // Binding Parameter: 'in' at first position in sequence, this is decisive!
      actionNode.append(new Edm.Parameter(v, { Name: bpName, Type: bpType }, {} ));
    }
    else // unbound => produce Action/FunctionImport
    {
      let actionImport = iAmAnAction
        ? new Edm.ActionImport(v, { Name: actionName, Action : fullQualified(actionName) })
        : new Edm.FunctionImport(v, { Name: actionName, Function : fullQualified(actionName) });

      let rt = actionCsn.returns && ((actionCsn.returns.items && actionCsn.returns.items.type) || actionCsn.returns.type);
      if(rt) // add EntitySet attribute only if return type is a non abstract entity
      {
        let definition = model.definitions[rt];
        if(definition && definition.kind == 'entity' && !definition.abstract)
        {
          actionImport.EntitySet = rt.replace(namespace, '');
        }
      }
      Schema._ec.append(actionImport);
    }

    // Parameter Nodes
    glue.forAll(actionCsn.params, (parameterCsn, parameterName) => {
      actionNode.append(new Edm.Parameter(v, { Name: parameterName }, parameterCsn ));
    });

    // return type if any
    if(actionCsn.returns) {
      actionNode._returnType = new Edm.ReturnType(v, actionCsn.returns, fullQualified);
      // if binding type matches return type add attribute EntitySetPath
      if(entityCsn != undefined && fullQualified(entityCsn.name) === actionNode._returnType._type) {
        actionNode.EntitySetPath = bpName;
      }
    }
    Schema.addAction(actionNode);
  }

  // add bound/unbound actions/functions for V2
  function createActionV2(actionCsn, name, entityCsn=undefined)
  {
    let functionImport = new Edm.FunctionImport(v, { Name: name.replace(namespace, '') } );

    // inserted now to maintain attribute order with old odata generator...
    /*
      V2 says (p33):
      * If the return type of FunctionImport is a collection of entities, the EntitySet
        attribute is defined.
      * If the return type of FunctionImport is of ComplexType or scalar type,
        the EntitySet attribute cannot be defined.
      The spec doesn't mention single ET: Ralf Handls confirmed that there is a gap
      in the spec and advised mention it as in V4
    */

    let rt = actionCsn.returns && ((actionCsn.returns.items && actionCsn.returns.items.type) || actionCsn.returns.type);
    if(rt) // add EntitySet attribute only if return type is an entity
    {
      let defintion = model.definitions[rt];
      if(defintion && glue.isEntityOrView(defintion))
      {
        functionImport.EntitySet = rt.replace(namespace, '');
      }
    }

    if(actionCsn.returns)
      functionImport.ReturnType = getReturnType(actionCsn);

    if(actionCsn.kind == 'function')
      functionImport.setXml( {'m:HttpMethod': 'GET' });
    else if(actionCsn.kind == 'action')
      functionImport.setXml( {'m:HttpMethod': 'POST'});
    else
      throw Error('Please debug me: Neither function nor action');

    if(entityCsn != undefined)
    {
      // Make bound function names always unique as per Ralf's recommendation
      functionImport.setXml( {'sap:action-for':  fullQualified(entityCsn.name) } );
      functionImport.Name = entityCsn.name.replace(namespace, '') + '_' + functionImport.Name;

      // Binding Parameter: Primary Keys at first position in sequence, this is decisive!
      // V2 XML: Nullable=false is set because we reuse the primary key property for the parameter
      glue.foreach(entityCsn.elements,
        elementCsn => elementCsn.key && !glue.isAssociationOrComposition(elementCsn),
        (elementCsn, elementName) => {
          functionImport.append(new Edm.Parameter(v, { Name: elementName }, elementCsn, 'In' ));
        }
      );
    }

    // is this still required?
    for (let p in actionCsn)
      if (p.match(/^@sap./)) 
        functionImport.setXml( { ['sap:' + p.slice(5).replace(/\./g, '-')] : actionCsn[p] });

    // then append all other parameters
    // V2 XML: Parameters that are not explicitly marked as Nullable or NotNullable in the CSN must become Nullable=true
    // V2 XML spec does only mention default Nullable=true for Properties not for Parameters so omitting Nullable=true let
    // the client assume that Nullable is false.... Correct Nullable Handling is done inside Parameter constructor
    glue.forAll(actionCsn.params, (parameterCsn, parameterName) => {
      functionImport.append(new Edm.Parameter(v, { Name: parameterName }, parameterCsn, 'In' ));
    });

    Schema._ec.append(functionImport);
  }

  function getReturnType(action)
  {
    // it is safe to assume that either type or items.type are set
    let type = action.returns && ((action.returns.items && action.returns.items.type) || action.returns.type);
    if(type && type.startsWith('cds.'))
      type = glue.mapCdsToEdmType(type, options.isV2());

    if(type && action.returns.items)
      type = `Collection(${type})`

    return type;
  }

  // returns a [ [ Edm Properties ], boolean hasStream ]
  // array of Edm Properties
  // boolean hasSstream : true if at least one element has @Core.MediaType assignment
  function createProperties(parentCsn)
  {
    let props = [];
    let hasStream = false;
    glue.forAll(parentCsn.elements, (elementCsn, elementName) =>
    {
      if(elementCsn._parent == undefined)
        setProp(elementCsn, '_parent', parentCsn);

      if(!elementCsn._ignore) {
        if(glue.isAssociationOrComposition(elementCsn))
        {
          // Foreign keys are part of the generic elementCsn.elements property creation

          // This is the V4 edmx:NavigationProperty
          // gets rewritten for V2 in addAssocations()

          // suppress navprop creation only if @odata.navigable:false is not annotated.
          // (undefined !== false) still evaluates to true
          if (!elementCsn.target.abstract && elementCsn['@odata.navigable'] !== false)
          {
            let navProp = new Edm.NavigationProperty(v, {
              Name: elementName,
              Type: fullQualified(elementCsn.target.name)
            }, elementCsn);

            props.push(navProp);
            // save the navProp in the global array for late constraint building
            navigationProperties.push(navProp);
          }
        }
        else if(!elementCsn['@cds.api.ignore'] || elementCsn['@cds.api.ignore'] !== true)
        {
          // CDXCORE-CDXCORE-173
          // V2: filter  @Core.MediaType
          // V4: filter foreignKey elements of Container associations
          let isContainerAssoc = false;
          if(elementCsn['@odata.foreignKey4']) {
            let assoc = parentCsn.elements[elementCsn['@odata.foreignKey4']];
            isContainerAssoc = assoc._isToContainer || assoc['@odata.contained'];
          }

          if(!(options.isV2() && elementCsn['@Core.MediaType']) &&
            !(options.isV4() && isContainerAssoc))
            props.push(new Edm.Property(v, { Name: elementName }, elementCsn));
          else
          {
            hasStream = true;
            // CDXCORE-CDXCORE-177: remove elementCsn from elements dictionary
            delete parentCsn.elements[elementName];
          }
        }
      }

    });
    return [ props, hasStream ];
  }

  function createComplexType(structuredTypeCsn) 
  {
    // V4 attributes: Name, BaseType, Abstract, OpenType
    let attributes = { Name: structuredTypeCsn.name.replace(namespace, '') };

    let complexType = new Edm.ComplexType(v, attributes, structuredTypeCsn);
    let elementsCsn = structuredTypeCsn.items || structuredTypeCsn;
    complexType.append(...(createProperties(elementsCsn)[0]));
    Schema.append(complexType);
  }

  // V4 <TypeDefintion>
  function createTypeDefinition(typeCsn)
  {
    // derived types are already resolved to base types
    let typeDef;
    let props = { Name: typeCsn.name.replace(namespace, '') };
    if((typeCsn.items && typeCsn.items.enum) || typeCsn.enum)
      typeDef = new Edm.EnumType(v, props, typeCsn);
    else
      typeDef = new Edm.TypeDefinition(v, props, typeCsn );
    Schema.append(typeDef);
  }

  /*
   * addAssociation() constructs a V2 association.
   * In V4 all this has been simplified very much, the only thing actually left over is
   * <ReferentialConstriant> that is then a sub element to <NavigationProperty>.
   * However, referential constraints are substantially different to its V2 counterpart,
   * so it is better to reimplement proper V4 construction of<NavigationProperty> in a separate
   * function.
   *
   * This method does:
   * rewrite <NavigationProperty> attributes to be V2 compliant
   * add <Association> elements to the schema
   * add <End>, <ReferentialConstraint>, <Dependent> and <Principal> sub elements to <Association>
   * add <AssociationSet> to the EntityContainer for each <Association>
   */
  function addAssociation(navigationProperty)
  {
    let constraints = navigationProperty._csn._constraints;
    let parentName = navigationProperty._csn._parent.name.replace(namespace, '');
    let plainAssocName = parentName + NAVPROP_TRENNER + navigationProperty.Name.replace(VALUELIST_NAVPROP_PREFIX, '');
    let assocName = plainAssocName;
    let i = 1;
    while(NamesInSchemaXRef[assocName] !== undefined) {
      assocName = plainAssocName + '_' + i++;
    }

    let fromRole = parentName;
    let toRole = navigationProperty.Type.replace(alias, ''); // <= navprops type should be prefixed with alias
  
    let fromEntityType = fromRole;
    let toEntityType = toRole;

    // The entity set name may not be the same as the type name (parameterized entities have 
    // differing set names (<T>Parameters => <T>, <T>Type => <T>Set)
    let fromEntitySet = ( navigationProperty._csn._parent.setName || fromEntityType).replace(namespace, '');
    let toEntitySet = (navigationProperty._targetCsn.setName || toEntityType).replace(namespace, '');

    // from and to roles must be distinguishable (in case of self association entity E { toE: association to E; ... })

    if(fromRole === toRole) {
      if(constraints._originAssocCsn)
        fromRole += '1';
      else
        toRole += '1';
    }

    // add V2 attributes to navigationProperty
    navigationProperty.Relationship = fullQualified(assocName);
    navigationProperty.FromRole = fromRole;
    navigationProperty.ToRole = toRole;

    // remove V4 attributes
    if(navigationProperty.Type != undefined)
      delete navigationProperty.Type;
    /* V2 erwaehnt kein Nullable genauso wie fuer Properties, TNT hats aber drin...
    if(navigationProperty.Nullable != undefined)
      delete navigationProperty.Nullable;
    */
    if(navigationProperty.Partner != undefined)
      delete navigationProperty.Partner;
    if(navigationProperty.ContainsTarget != undefined)
      delete navigationProperty.ContainsTarget;

    /*
      If NavigationProperty is a backlink association (constraints._originAssocCsn is set), then there are two options:
      1) Counterpart NavigationProperty exists and is responsible to create the edm:Association element which needs to
        be reused by this backlink association. This is save because at this point of the processing all NavProps are created.
      2) Counterpart NavigationProperty does not exist (@odata.navigable:false), then the missing edm:Association element
        of the origin association needs to be created as if it would have been already available in case (1).
     */

    let reuseAssoc = false;
    let forwardAssocCsn = constraints._originAssocCsn;
    if(forwardAssocCsn)
    {
      // This is a backlink, swap the roles and types, rewrite assocName
      [ fromRole, toRole ] = [ toRole, fromRole ];
      [ fromEntityType, toEntityType ] = [ toEntityType, fromEntityType ];
      [ fromEntitySet, toEntitySet ] = [ toEntitySet, fromEntitySet ];

      parentName = forwardAssocCsn._parent.name.replace(namespace, '');
      assocName = plainAssocName = parentName + NAVPROP_TRENNER + forwardAssocCsn.name.replace(VALUELIST_NAVPROP_PREFIX, '');
      i = 1;
      while(NamesInSchemaXRef[assocName] !== undefined && !(NamesInSchemaXRef[assocName][0] instanceof Edm.Association)) {
        assocName = plainAssocName + '_' + i++;
      }

      navigationProperty.Relationship = fullQualified(assocName)

      reuseAssoc = !!forwardAssocCsn._NavigationProperty;
      constraints = glue.getReferentialConstraints(forwardAssocCsn, signal, warning);
      constraints._multiplicity = glue.determineMultiplicity(forwardAssocCsn);
    }

    if(reuseAssoc)
    {
      // Example:
      // entity E { key id: Integer; toF: association to F; };
      // entity F { key id: Integer; toE: composition of E on toE.toF = $self; };
      //
      // Consider we're in NavigationProperty 'toE' which is the backlink to F.
      // Then forwardAssocCsn is 'E_toF' with two Ends: E, F.
      // Backlink F.toE is a composition, making E existentially dependant on F.
      // So End E of Association E_toF (which is End[0]) receives Edm.OnDelete.
      // Depending on the order of the navigation properties it might be that the
      // forward Edm.Association has not yet been produced. In this case Edm.OnDelete
      // is parked at the forward NavigationProperty.

      if(!forwardAssocCsn._NavigationProperty._edmAssociation && navigationProperty._csn.type == 'cds.Composition')
      {
        // TODO: to be specified via @sap.on.delete
        forwardAssocCsn._NavigationProperty.set( { _OnDeleteSrcEnd: new Edm.OnDelete(v, { Action: 'Cascade' }) } );
      }
      return;
    }

    // Create Association and AssociationSet if this is not a backlink association.
    // Store association at navigation property because in case the Ends must be modified
    // later by the partner (backlink) association
    navigationProperty._edmAssociation = new Edm.Association(v, { Name: assocName }, navigationProperty,
                                    [ fromRole, fullQualified(fromEntityType) ],
                                    [ toRole, fullQualified(toEntityType) ],
                                    constraints._multiplicity );
    if(NamesInSchemaXRef[assocName] === undefined) {
      NamesInSchemaXRef[assocName] = [ navigationProperty._edmAssociation ];
    }
    else {
      navigationProperty._edmAssociation.push(navigationProperty._edmAssociation);
    }
    // Add ReferentialConstraints if any
    if(!navigationProperty._isCollection && Object.keys(constraints.constraints).length > 0) {
      // A managed composition is treated as association
      if(navigationProperty._csn.type == 'cds.Composition' && (navigationProperty._csn.on || navigationProperty._csn.onCond)) {
        navigationProperty._edmAssociation.append(Edm.ReferentialConstraint.createV2(v,
          toRole, fromRole, constraints.constraints));
      }
      else {
        navigationProperty._edmAssociation.append(Edm.ReferentialConstraint.createV2(v,
          fromRole, toRole, constraints.constraints));
      }
    }

    Schema.append(navigationProperty._edmAssociation);

    let assocSet =  new Edm.AssociationSet(v, { Name: assocName, Association: fullQualified(assocName) },
      fromRole, toRole, fromEntitySet, toEntitySet);
    Schema._ec.append(assocSet);
  }

  // produce a full qualified name replacing the namespace with the alias (if provided)
  function fullQualified(name) 
  {
    if (name == serviceCsn.name)
      return Schema.Alias
    else
      return alias + name.replace(namespace, '')
  }

  function createAnnotations(edm)
  {
    let annoEdm;
    annoEdm = translate.csn2annotationEdm(model, options);
    
    for(let i = 0; i < annoEdm.getSchemaCount(); i++)
    {
      edm.setAnnotations(annoEdm.getAnnotations(i), i);
    }
    edm._defaultRefs = annoEdm._defaultRefs;
  }
}
