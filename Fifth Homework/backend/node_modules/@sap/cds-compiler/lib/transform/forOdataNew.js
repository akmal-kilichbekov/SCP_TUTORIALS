'use strict';

const alerts = require('../base/alerts');
// const { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { forEachDefinition, forEachMemberRecursively, setProp } = require('../base/model');
const transformUtils = require('./transformUtilsNew');
const { mergeOptions, copyAnnotations, getElementDatabaseNameOf, hasBoolAnnotation } = require('../model/modelUtils');
const { getUtils } = require('../model/csnUtils');

// Transformation for ODATA. Expects a CSN 'inputModel', processes it for ODATA.
// The twin of forOdata.js
// The result should be suitable for consumption by EDMX processors (annotations and metadata)
// and also as a final CSN output for the ODATA runtime (when compacted).
// Performs the following transformations:
//
//   (1) Flatten structured elements (and foreign keys of managed associations pointing to
//       keys that are themselves managed associations).
//       TODO: probably only for OData V2?
//   (2) Expose (named or anonymous) structured types used in structured types
//   (3) Unravel derived types for elements, actions, action parameters, types and
//       annotations (propagating annotations)
//   (4) Flatten on-conditions in unmanaged associations
//   (5) Mark fields with @odata.on.insert/update as @Core.Computed
//   (6) Rename shorthand annotations according to a builtin list.
//       e.g. @label -> @Common.Label or @important: [true|false] -> @UI.Importance: [#High|#Low]
//   (7) Check annotations. If annotation starts with '@sap...' it must have a string or boolean value
//  Transformations (1), (2), (3), (4), (5), (6) and (7) are executed during the first walk through the model
//
//   (8) For exposed actions and functions that use non-exposed or anonymous structured types,
//       create artificial exposing types
//  Transformation (8) is a second walk through the definitions
//
//   (9) Generate foreign key fields for managed associations, depends on (1) in V4 or flatten case
//  Step (9) is in the third walk of the model
//
//   (10) Generate artificial draft fields if requested
//   (11) Perform checks and add attributes for "contained" sub-entities
//   (12) Check associations for:
//        - exposed associations do not point to non-exposed targets
//        - structured types must not contain associations for OData V2
//   (13) Element must not be an 'array of' for OData V2
//   (14) If the association target is annotated with @cds.odata.valuelist, annotate the
//        association with @Common.ValueList.viaAssociation
//   (15) Check for @Analytics.Measure and @Aggregation.default
//  Fourth loop: (10) to (15)
//
//   (16) Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
//   (17) Perform checks for exposed non-abstract entities and views - check media type and
//        key-ness (requires that containers have been identified in the fourth pass (11))
//  Fifth walk through the model with (16) and (17)

module.exports = { transform4odataWithCsn, getServiceNames };

function transform4odataWithCsn(inputModel, options) {
  const { error, warning, signal } = alerts(inputModel);
  // copy the model as we don't want to change the input model
  // TODO: we agreed on JSON.parse(JSON.stringify... or ... ???
  let csn = JSON.parse(JSON.stringify(inputModel));

  setProp(csn, 'messages', inputModel.messages);

  options = mergeOptions(inputModel.options, options);
  setProp(csn, 'options', options);

  const {
    flattenForeignKeys, createForeignKeyElement,
    flattenStructuredElement, flattenOnCond,
    checkExposedAssoc, toFinalBaseType, getServiceName,
    createAndAddDraftAdminDataProjection, createScalarElement,
    createAssociationElement, createAssociationPathComparison,
    addElement, createAction,
    addAction, copyAndAddElement,
    // to be implemented for temporal
    /* extractValidFromToKeyElement, checkAssignment, checkMultipleAssignments */
  } = transformUtils.getTransformers(csn, '_');

  const {
    getArtifactDatabaseNameOf,
    getCsnDef,
    getFinalType,
    getFinalTypeDef,
    getNamespaceOfArtifact,
    isBuiltinType,
    isAssocOrComposition,
    isAssociation,
    isManagedAssociationElement,
    isStructured,
  } = getUtils(csn);

  // collect all declared non-abstract services from the model
  // use the array when there is a need to identify if an artifact is in a service or not
  let services = getServiceNames(csn);

  // First walk: 
  // (1) Flatten structs
  // (2) Expose (named or anonymous) structured types used in structured types
  // (3) Unravel derived type chains,
  // (4) Flatten on-conditions in unmanaged associations
  // (5) Mark fields with @odata.on.insert/update as @Core.Computed
  // (6) Resolve annotation shorthands,
  // (7) Check @cds... annotations
  // TODO: only for V2 or via special option???
  forEachDefinition(csn, (def, defName) => {
    // (1) Flatten structs - for entities and views only (might result in new elements)
    if (def.kind === 'entity' || def.kind === 'view') {
      for (let elemName in def.elements) {
        let elem = def.elements[elemName];
        if (isStructured(elem, csn) || (elem.type && getFinalTypeDef(elem.type, csn).elements)) {
          // Remove the structured element, replace it by its flattened form
          delete def.elements[elemName];
          let flatElems = flattenStructuredElement(elem, elemName);
          for (let flatElemName in flatElems) {
            if (def.elements[flatElemName]) {
              signal(error`"${defName}.${elemName}": Flattened struct element name conflicts with existing element: "${flatElemName}"`);
            }
            def.elements[flatElemName] = flatElems[flatElemName];
          }
        }
      }
    }
    // (2) Expose (named or anonymous) structured types used in structured types
    else if (isArtifactInSomeService(defName, services) && def.kind == 'type') {
      for (let elemName in def.elements) {
        let elem = def.elements[elemName];
        // Expose structured types used in exposed structured types
        exposeStructTypeOf(elem, getServiceOfArtifact(defName, services), `__${defName.replace(/\./g, '_')}_${elemName}`);
      }
    }


    forEachMemberRecursively(def, (member, memberName) => {
      // (3) Unravel derived type chains for elements, actions, action parameters (propagating annotations)
      toFinalBaseType(member);
      toFinalBaseType(member.items);
      toFinalBaseType(member.returns);
      toFinalBaseType(member.returns && member.returns.items);

      // (4) Flatten on-conditions in unmanaged associations
      if (member.type && isAssocOrComposition(member.type, csn) && member.on) {
        flattenOnCond(member, memberName, def.elements);
      }

      // (5) Mark fields with @odata.on.insert/update as @Core.Computed
      annotateCoreComputed(member);

      // (6) Resolve annotation shorthands for elements, actions, action parameters
      renameShorthandAnnotations(member);

      // (7) check annotations
      checkAnnotations(member);
    });


    // (3) Unravel derived type chains for types and annotations (propagating annotations)
    if (def.kind != 'entity') {
      toFinalBaseType(def);
      toFinalBaseType(def.items);
      toFinalBaseType(def.returns);
      toFinalBaseType(def.returns && def.returns.items);
    }

    // If the artifact is a derived structured type, unravel that as well
    // "S.Struct2": { "kind": "type", "type": "S.Struct1",
    //   "elements":
    //     { "a": { "type": "cds.Integer" },
    //       "b": { "type": "cds.Integer" } }
    // } where S.Struct1 is also struct type def and the elements come from there
    if (def.kind == 'type' && def.type &&
      !isBuiltinType(def.type) && getCsnDef(def.type).elements) {
      // elements are already there -> do not show the type
      delete def.type;
    }
    // (6) Resolve annotation shorthands for entities, types, annotations, ...
    renameShorthandAnnotations(def);
    // (7) check annotations
    checkAnnotations(def);
  });

  // Second walk: Only through definitions
  // (8) For exposed actions and functions that use non-exposed or anonymous structured types, create
  // artificial exposing types
  forEachDefinition(csn, (def, defName) => {
    let service = getServiceOfArtifact(defName, services);
    if (service) {
      if (def.kind == 'action' || def.kind == 'function') {
        exposeStructTypesForAction(def, defName, service);
      }

      for (let actionName in def.actions || {}) {
        exposeStructTypesForAction(def.actions[actionName], `${defName}_${actionName}`, service);
      }
    }
  });

  // Third walk: (9) Generate foreign key fields for managed associations (must be done
  // after struct flattening, otherwise we might encounter already generated foreign
  // key fields in types we have already processed)
  forEachDefinition(csn, (def) => {
    forEachMemberRecursively(def, (member, memberName) => {
      // Generate foreign key elements for managed associations
      if (isManagedAssociationElement(member) && !member._ignore) {
        // Flatten foreign keys (replacing foreign keys that are managed associations by their respective foreign keys)
        member.keys = flattenForeignKeys(member.keys, member.target);
        // Generate foreign key elements
        for (let key of member.keys) {
          let foreignKeyElement = createForeignKeyElement(member, memberName, key, def);
          toFinalBaseType(foreignKeyElement);
          // Propagate the association's annotations to the foreign key element
          // (Overwriting because they should win over the derived type unraveling)
          copyAnnotations(member, foreignKeyElement, true);
        }
        // If the managed association is NOT NULL, we give it a target min cardinality of 1
        // if it didn't already have an explicitly specified min cardinality.
        // (No need to check again for min <= max cardinality, because max has already been checked to be > 0)
        if (member.notNull) {
          if (!member.cardinality) {
            member.cardinality = {};
          }
          if (member.cardinality.min === undefined) {
            member.cardinality.min = 1;
          }
        }
      }
    });
  });

  // Fourth walk through the model: Now all artificially generated things are in place
  // (10) Generate artificial draft fields if requested
  // TODO: should be done by the compiler - Check associations for valid foreign keys
  // (11) Perform checks and add attributes for "contained" sub-entities
  // TODO: checkif needed at all: Remove '$projection' from paths in the element's ON-condition
  // (12) Check associations for:
  //        - exposed associations do not point to non-exposed targets
  //        - structured types must not contain associations for OData V2
  // (13) Element must not be an 'array of' for OData V2
  // (14) If the association target is annotated with @cds.odata.valuelist, annotate the
  //      association with @Common.ValueList.viaAssociation
  // (15) Check for @Analytics.Measure and @Aggregation.default
  forEachDefinition(csn, (def, defName) => {
    if (def.kind == 'entity' || def.kind == 'view') {
      // (10) Generate artificial draft fields if requested
      if (def['@odata.draft.enabled']) {
        // Ignore if not part of a service
        if (!isArtifactInSomeService(defName, services)) {
          signal(warning`Ignoring annotation "@odata.draft.enabled" - artifact "${defName}" is not part of a service`);
        }
        else {
          generateDraftForOdata(def, defName, def);
        }
      }

      for (let elemName in def.elements) {
        let elem = def.elements[elemName];
        // Check for valid foreign keys
        // this should actually be done by the compiler
        // if (isAssocOrComposition(elem.type)) {
        //   checkForeignKeys(elem);
        // }

        // (11) Perform checks and add attributes for "contained" sub-entities:
        // - A container is recognized by having an association annotated with '@odata.contained'.
        // - All targets of such associations ("containees") are marked with a property 
        //   '_containerEntity: []', having as value an array of container names (i.e. of entities
        //   that have a '@odata.contained' association pointing to the containee). Note that this
        //   may be multiple entities, possibly including the container itself.
        // - All associations in the containee pointing back to the container are marked with
        //   a boolean property '_isToContainerEntity : true', except if the association itself
        //   has the annotation '@odata.contained' (indicating the top-down link in a hierarchy).
        // - All associations in the containee pointing back to the container must have a specific
        //   setting for 'NOT NULL': Required if container and containee are different entities
        //   (header/item scenario), not allowed if they are identical (hierarchy scenario).
        //   FIXME: This currently requires that only managed associations can point from containee
        //   back to container in the header/item scenario, because CDS syntax does not allow 'NOT NULL'
        //   for unmanaged associations). If unmanaged associations are also wanted, we would have to
        //   omit this check for them.
        if (elem['@odata.contained'] && elem.target) {
          // Retrieve the containee artifact
          let containedArtifactName = elem.target;
          let containedArtifact = getCsnDef(containedArtifactName);
          // Sanity check
          if (!containedArtifact) {
            throw new Error('Expected target artifact of @odata.contained assoc to be resolved: ' + JSON.stringify(elem));
          }
          // Let the containee know its container (array because their may be more than one)
          if (!containedArtifact._containerEntity) {
            containedArtifact._containerEntity = [];
          }
          // add container only once
          if (containedArtifact._containerEntity.includes(defName)) {
            signal(error`"${defName}": Entity is already recursively contained`);
            continue;
          }
          containedArtifact._containerEntity.push(defName);
          // Mark associations in the containee pointing to the container (i.e. to this entity)
          for (let containedElemName in containedArtifact.elements) {
            let containedElem = containedArtifact.elements[containedElemName];
            if (isAssocOrComposition(containedElem.type)) {
              // Sanity check
              if (!containedElem.target || !getCsnDef(containedElem.target)) {
                throw new Error('Expected target artifact of assoc in container to be resolved: ' + JSON.stringify(containedElem));
              }
              // If this is an association that points to a container (but is not by itself contained,
              // which would indicate the top role in a hierarchy) mark it with '_isToContainer'
              if (containedElem.target == defName && !containedElem['@odata.contained']) {
                containedElem._isToContainer = true;
                // If this is really a header/item relationship (i.e. two different entities involved), the
                // association to the container must be NOT NULL
                if (containedArtifactName != defName) {
                  // FIXME: See above: We could also omit the check for unmanaged assocs
                  // if (!containedElem.onCond && !containedElem.notNull)
                  if (!containedElem.notNull) {
                    signal(warning`"${containedArtifactName}.${containedElemName}": Association to container entity must have "NOT NULL"`);
                  }
                }
                // Otherwise (recursive hierarchy relationship, only one entity involved), it must not be NOT NULL
                else {
                  if (containedElem.notNull) {
                    signal(warning`"${containedArtifactName}.${containedElemName}": Association to container entity in a recursive hierarchy must not have "NOT NULL"`);
                  }
                }
              }
            }
          }
        }

        // // Remove '$projection' from paths in the element's ON-condition
        // // FIXME: Hack - should actually be done by the compiler, and should only
        // // affect the element itself, not the various other places sharing the same
        // // ON-condition object, e.g. the MIXIN and the query (there, the ON-condition
        // // should actually retain its '$projection').
        // foreachPath(elem.onCond || {}, (path, node) => {
        //   if (path[0].id == '$projection') {
        //     node.path = node.path.slice(1);
        //   }
        // });
      }
    }
    forEachMemberRecursively(def, (member, memberName) => {
      if (isArtifactInSomeService(defName, services)) {
        let service = getServiceOfArtifact(defName, services);
        // (12) Check associations
        if (isAssocOrComposition(member.type, csn)) {
          // Check that exposed associations do not point to non-exposed targets
          checkExposedAssoc(defName, member, memberName, service);

          // CDXCORE-457
          if (def.kind === 'type' && options.toOdata.version == 'v2') {
            signal(warning`"${defName}.${memberName}": Structured types must not contain associations for OData V2`);
          }
        }
        // (13) CDXCORE-458
        else if (member.kind == 'element' && member.items && options.toOdata.version == 'v2') {
          signal(error`"${defName}.${memberName}": Element must not be an "array of" for OData V2`);
        }


        // (14) If the member is an association and the target is annotated with @cds.odata.valuelist,
        // annotate the association with @Common.ValueList.viaAssociation (but only for service member artifacts
        // to avoid CSN bloating). The propagation of the @Common.ValueList.viaAssociation annotation
        // to the foreign keys is done very late in csn2edm.glue.initializeAssociation()
        addCommonValueListviaAssociation(member, memberName);

        // (15) https://github.wdf.sap.corp/cdx/cds-compiler/issues/837
        // add check here for @Analytics.Measure and @Aggregation.default
        // @Analytics has scope element
        if (member.kind && member.kind === 'element'
          && member['@Analytics.Measure'] && !member['@Aggregation.default']) {
          signal(
            warning`'@Analytics.Measure' expects '@Aggregation.default' to be assigned as well in element '${member.name.absolute}.${member.name.id}'`
          );
        }
      }
    });
  });

  // Fifth walk through the model:
  // (16) Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
  // (17) Perform checks for exposed non-abstract entities and views - check media type and
  //      key-ness (requires that containers have been identified in the fourth pass (11))
  let illV2Prefix = RegExp('^(_|[0-9])');
  forEachDefinition(csn, (def, defName) => {
    // (16) Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
    if (options.toOdata.names) {
      // Skip artifacts that have no DB equivalent anyway
      if (!['service', 'context', 'namespace', 'annotation', 'action', 'function'].includes(def.kind)) {
        def['@cds.persistence.name'] = getArtifactDatabaseNameOf(defName, options.toOdata.names, getNamespaceOfArtifact(defName));
      }
      forEachMemberRecursively(def, (member, memberName, prop) => {
        // Only these are actually required and don't annotate virtual elements in entities or types
        // as they have no DB representation (although in views)
        if (typeof member === 'object' && !['action', 'function'].includes(member.kind) && prop !== 'enum' && (!member.virtual || def.query)) {
          // If we have a 'preserved dotted name' (i.e. we are a result of flattening), use that for the @cds.persistence.name annotation
          if (member._flatElementNameWithDots) {
            memberName = member._flatElementNameWithDots;
          }
          member['@cds.persistence.name'] = getElementDatabaseNameOf(memberName, options.toOdata.names);
        }
      });
    }

    // (17) Perform checks for exposed non-abstract entities and views
    if (isArtifactInSomeService(defName, services) && !def.abstract && (def.kind == 'entity' || def.kind == 'view')) {
      let keyCount = 0;
      let mediaTypes = [];
      // Walk the elements
      let eltCount = 0;
      for (let elemName in def.elements) {
        let elem = def.elements[elemName];

        // For ODATA V2, element names must not start with digit or '_'
        if (options.toOdata.version == 'v2') {
          if (illV2Prefix.test(elemName)) {
            signal(error`"${defName}.${elemName}: Element name must not begin with '${elemName[0]}' for OData V2`);
          }
        }

        // Count keys and elements annotated with @Core.MediaType
        let ignore = elem['@cds.api.ignore'];
        if (!elem._ignore) {
          eltCount++;
          if (elem.key && !ignore) {
            keyCount++;
          }
        }
        if (elem['@Core.MediaType']) {
          mediaTypes.push([elemName, elem]);
        }
      }

      if (eltCount == 0) {
        signal(error`Entity "${defName}" must have at least one element`);
      }
      // Exposed non-abstract entities in non-contained artifacts must have a key
      if (keyCount == 0 && !def._containerEntity) {
        signal(error`Entity "${defName}" does not have a key: ODATA entities must have a key`);
      }

      // Additional checks for ODATA V2 regarding remaining keys
      if (options.toOdata.version == 'v2') {
        // Elements that are annotated with @Core.HasStream are removed from the entity type.
        // If these are all keys then this would end up with a key-less EntityType wich is illegal in V2
        let mtkeys = mediaTypes.filter(e => e[1].key);
        if (mtkeys.length > 0 && keyCount == mtkeys.length) {
          signal(error`"${defName}: Key elements [${mtkeys.map(e => e[0]).join(', ')}] annotated with '@Core.MediaType' are removed from Odata V2 resulting in keyless EntityType`);
        }
        // Today only one MediaType is allowed in V2
        if (mediaTypes.length > 1) {
          signal(error`"${defName}: Elements [${mediaTypes.map(e => e[0]).join(', ')}] annotated with '@Core.MediaType', OData V2 allows only one`);
        }
      }

      // Check media type compatibility for all OData versions
      let allowedTypes = ['cds.String', 'cds.Binary', 'cds.LargeBinary'];
      mediaTypes.forEach(e => {
        if (!allowedTypes.includes(e[1].type)) {
          signal(error`"${defName}.${e[0]}": Element annoted with '@Core.MediaType' must be of either type "${allowedTypes.join(', ')}"`);
        }
      });
    }
  });

  // TODO: message handling is still under discussion
  // Throw up if we have errors
  // if (hasErrors(model.messages)) {
  //   throw new CompilationError(sortMessages(model.messages), model);
  // }

  // until message situation is clear
  delete csn.messages;
  return csn;

  // (5) Mark elements that are annotated with @odata.on.insert/update with the annotation @Core.Computed.
  // Implements: CDXCORE-62
  function annotateCoreComputed(node) {
    // If @Core.Computed is explicitly set, don't overwrite it!
    if (node['@Core.Computed']) return;

    // For @odata.on.insert/update, also add @Core.Computed
    if (node['@odata.on.insert'] || node['@odata.on.update'])
      node['@Core.Computed'] = true;
  }

  // (6) Rename shorthand annotations within artifact or element 'node' according to a builtin
  // list.
  function renameShorthandAnnotations(node) {
    // FIXME: Verify this list - are they all still required? Do we need any more?
    const mappings = {
      '@label': '@Common.Label',
      '@title': '@Common.Label',
      '@ValueList.entity': '@Common.ValueList.entity',
      '@ValueList.type': '@Common.ValueList.type',
      '@Capabilities.Deletable': '@Capabilities.DeleteRestrictions.Deletable',
      '@Capabilities.Insertable': '@Capabilities.InsertRestrictions.Insertable',
      '@Capabilities.Updatable': '@Capabilities.UpdateRestrictions.Updatable',
    }

    for (let name in node) {
      // Rename according to map above
      if (mappings[name] != undefined)
        renameAnnotation(node, name, mappings[name]);

      // Special case: '@important: [true|false]' becomes '@UI.Importance: [#High|#Low]'
      if (name == '@important') {
        renameAnnotation(node, name, '@UI.Importance');
        let annotation = node['@UI.Importance'];
        node['@UI.Importance'] = { '#': annotation ? 'High' : 'Low' }
      }

      // Special case: '@readonly' becomes a triplet of capability restrictions for entities,
      // but '@Core.Immutable' for everything else.
      if (name == '@readonly') {
        if (node.kind == 'entity' || node.kind == 'view') {
          node['@Capabilities.DeleteRestrictions.Deletable'] = false;
          node['@Capabilities.InsertRestrictions.Insertable'] = false;
          node['@Capabilities.UpdateRestrictions.Updatable'] = false;
        } else {
          renameAnnotation(node, name, '@Core.Computed');
        }
      }
    }
  }

  // (7) Apply checks to all annotations in the model
  // node: artifact/element/action/function/parameter/... that carries the annotations
  function checkAnnotations(node) {
    // currently there is only one check: annotations @sap:... must have a string or boolean value
    //   or no value (as shorcut for boolean value true)
    let annoNames = Object.keys(node).filter(x => x.startsWith('@sap.'));
    for (let name of annoNames) {
      if (typeof node[name] == 'boolean' || typeof node[name] == 'string') {
        signal(warning`Annotation "${name}" must have a string or boolean value`);
      }
    }
  }

  // (8) If 'action' uses structured types as parameters or return values that are not exposed in 'service'
  // (because the types are anonymous or have a definition outside of 'service'), create equivalent types
  // in 'service' and make 'action' use them instead
  function exposeStructTypesForAction(action, actionName, service) {
    exposeStructTypeOf(action.returns, service, `__return_${actionName.replace(/\./g, '_')}`);
    for (let paramName in action.params || {}) {
      exposeStructTypeOf(action.params[paramName], service, `__param_${actionName.replace(/\./g, '_')}_${paramName}`);
    }
  }

  // (2), (8) If 'node' exists and has a structured type that is not exposed in 'service', (because the type is
  // anonymous or has a definition outside of 'service'), create an equivalent type in 'service', either
  // using the type's name or (if anonymous) 'artificialName', and make 'node' use that type instead.
  // Complain if there is an error.
  function exposeStructTypeOf(node, service, artificialName) {
    if (!node) {
      return;
    }
    if (node.items) {
      exposeStructTypeOf(node.items, service, artificialName);
    }

    if (/* anonymos type */node.elements
      || (node.type && !isArtifactInService(node.type, service))
      && (node.type && !node.type.startsWith('cds.'))) {
      let typeDef = node.type ? getCsnDef(node.type) : /* anonymos type */ node;
      if (typeDef && isStructured(typeDef, csn) || (node.type && !node.type.startsWith(service))) {
        let typeId = node.type ? `__${node.type.replace(/\./g, '_')}` : artificialName;
        let type = exposeStructType(typeId, typeDef.elements, service);
        if (!type) {
          // Error already reported
          return;
        }
        // Recurse into elements of 'type' (if any)
        for (let elemName in type.elements) {
          exposeStructTypeOf(type.elements[elemName], service, `${typeId}_${elemName}`);
        }
        node.type = `${service}.${typeId}`;
      }
    }
  }

  // (2), (8) Expose an artificial structured type with ID 'typeId' with 'elements' in 'service' (reusing such a type
  // if it already exists).
  // Return the exposed type. Report any errors
  function exposeStructType(typeId, elements, service) {
    let typeName = `${service}.${typeId}`;
    // If type already exists, reuse it (complain if not created here)
    let type = csn.definitions[typeName];
    if (type) {
      // if (type.$inferred == 'actionType') {
      //   return type;
      // } else {
      signal(warning`Cannot create artificial type "${typeName}" for an action or function because the name is already used`);
      return type;
      // }
    }
    // Create type with empty elements
    type = {
      kind: 'type',
      elements: Object.create(null),
      // TODO: clarify if we should set $inferren
      // $inferred: 'actionType',
    };
    // Duplicate the type's elements
    for (let elemName in elements) {
      copyAndAddElement(elements[elemName], type, elemName);
    }
    csn.definitions[typeName] = type;
    return type;
  }

  // (10) Generate all that is required in ODATA for draft enablement of 'artifact' into the artifact,
  // into its transitively reachable composition targets, and into the model.
  // 'rootArtifact' is the root artifact where composition traversal started.
  function generateDraftForOdata(artifact, artifactName, rootArtifact) {
    // Sanity check
    if (!isArtifactInSomeService(artifactName, services)) {
      throw new Error('Expecting artifact to be part of a service: ' + JSON.stringify(artifact));
    }

    // Nothing to do if already draft-enabled (composition traversal may have circles)
    if ((artifact['@Common.DraftRoot.PreparationAction'] || artifact['@Common.DraftNode.PreparationAction'])
      && artifact.actions && artifact.actions.draftPrepare) {
      return;
    }

    // FIXME: Current restriction: Must only have exactly one key, which is of type UUID
    let keyNames = Object.keys(artifact.elements).filter(elemName => {
      return artifact.elements[elemName].key && artifact.elements[elemName].key === true;
    });
    if (keyNames.length != 1) {
      signal(warning`"${artifactName}": Ignoring annotation "@odata.draft.enabled" - currently only supported for artifacts with exactly one key of type "UUID"`);
      return;
    }
    let keyElem = artifact.elements[keyNames[0]];
    if (keyElem.type != 'cds.UUID' /* && keyElem._finalType.name.$renamed != 'cds.UUID' */) {
      signal(warning`"${artifactName}": Ignoring annotation "@odata.draft.enabled" - currently only supported for key of type "UUID"`);
      return;
    }

    // Generate the DraftAdministrativeData projection into the service, unless there is already one
    let draftAdminDataProjectionName = `${getServiceOfArtifact(artifactName, services)}.DraftAdministrativeData`;
    let draftAdminDataProjection = csn.definitions[draftAdminDataProjectionName];
    if (!draftAdminDataProjection) {
      draftAdminDataProjection = createAndAddDraftAdminDataProjection(getServiceOfArtifact(artifactName, services));
    }
    // Barf if it is not an entity or not what we expect
    if (draftAdminDataProjection.kind != 'entity' || !draftAdminDataProjection.elements['DraftUUID']) {
      signal(error`Generated entity "${draftAdminDataProjectionName}" conflicts with existing artifact`);
    }

    // Generate the annotations describing the draft actions (only draft roots can be activated/edited)
    if (artifact == rootArtifact) {
      artifact['@Common.DraftRoot.PreparationAction'] = 'draftPrepare';
      artifact['@Common.DraftRoot.ActivationAction'] = 'draftActivate';
      artifact['@Common.DraftRoot.EditAction'] = 'draftEdit';
    } else {
      artifact['@Common.DraftNode.PreparationAction'] = 'draftPrepare';
    }

    // Generate the additional elements into the draft-enabled artifact

    // key IsActiveEntity : Boolean default true
    let isActiveEntity = createScalarElement('IsActiveEntity', 'cds.Boolean', true, true);
    addElement(isActiveEntity, artifact);

    // HasActiveEntity : Boolean default false
    let hasActiveEntity = createScalarElement('HasActiveEntity', 'cds.Boolean', false, false);
    addElement(hasActiveEntity, artifact);

    // HasDraftEntity : Boolean default false;
    let hasDraftEntity = createScalarElement('HasDraftEntity', 'cds.Boolean', false, false);
    addElement(hasDraftEntity, artifact);

    // @odata.contained: true
    // DraftAdministrativeData : Association to one DraftAdministrativeData;
    let draftAdministrativeData = createAssociationElement('DraftAdministrativeData', draftAdminDataProjectionName, true);
    draftAdministrativeData.DraftAdministrativeData.cardinality = { max: 1, };
    draftAdministrativeData.DraftAdministrativeData['@odata.contained'] = true;
    addElement(draftAdministrativeData, artifact);
    // Note that we need to do the ODATA transformation steps for managed associations
    // (foreign key field generation, generatedFieldName) by hand, because the corresponding
    // transformation steps have already been done on all artifacts when we come here)
    let uuidDraftKey = draftAdministrativeData.DraftAdministrativeData.keys.filter(key => key.ref && key.ref.length === 1 && key.ref[0] === 'DraftUUID');
    if (uuidDraftKey) {
      uuidDraftKey = uuidDraftKey[0]; // filter returns an array, but it has only one element
      let foreignKeyElement = createForeignKeyElement(draftAdministrativeData.DraftAdministrativeData, 'DraftAdministrativeData', uuidDraftKey, artifact);
      foreignKeyElement['@odata.contained'] = true;
    }
    // SiblingEntity : Association to one <artifact> on (... IsActiveEntity unequal, all other key fields equal ...)
    let siblingEntity = createAssociationElement('SiblingEntity', artifactName, false);
    siblingEntity.SiblingEntity.cardinality = { max: 1 };
    addElement(siblingEntity, artifact);
    // ... on SiblingEntity.IsActiveEntity != IsActiveEntity ...
    siblingEntity.SiblingEntity.on = createAssociationPathComparison('SiblingEntity', 'IsActiveEntity', '!=', 'IsActiveEntity');

    // Iterate elements
    for (let elemName in artifact.elements) {
      let elem = artifact.elements[elemName];
      if (elemName != 'IsActiveEntity' && elem.key) {
        // Amend the ON-condition above:
        // ... and SiblingEntity.<keyfield> = <keyfield> ... (for all key fields except 'IsActiveEntity')
        let cond = createAssociationPathComparison('SiblingEntity', elemName, '=', elemName);
        cond.push('and');
        cond.push(...siblingEntity.SiblingEntity.on);
        siblingEntity.SiblingEntity.on = cond;
      }

      // Make all non-key elements nullable
      if (elem.notNull && !(elem.key && elem.key === true)) {
        elem.notNull = false;
      }

      // Draft-enable the targets of composition elements (draft nodes), too
      // TODO rewrite
      if (elem.target && elem.type && getFinalType(elem.type) === 'cds.Composition') {
        let draftNode = csn.definitions[elem.target];
        // Ignore if that is our own draft root
        if (draftNode != rootArtifact) {
          // Barf if the draft node has @odata.draft.enabled itself
          if (hasBoolAnnotation(draftNode, '@odata.draft.enabled')) {
            signal(error`"${elem.name.absolute}.${elem.name.element}": Composition in draft-enabled entity cannot lead to another entity with "@odata.draft.enabled"`, elem.location);
          }
          // Ignore composition if not part of a service
          else if (!getServiceName(elem.target)) {
            signal(warning`Target "${draftNode.name.absolute}" of composition "${elem.name.absolute}.${elem.name.element}" cannot be a draft node because it is not part of a service`, elem.location);
            continue;
          }
          else if (hasBoolAnnotation(draftNode, '@odata.draft.enabled', false)) {
            continue;
          }
          else {
            // Generate draft stuff into the target
            generateDraftForOdata(draftNode, elem.target, rootArtifact);
          }
        }
      }
    }

    // Generate the actions into the draft-enabled artifact (only draft roots can be activated/edited)

    // action draftPrepare (SideEffectsQualifier: String) return <artifact>;
    let draftPrepare = createAction('draftPrepare', artifactName, 'SideEffectsQualifier', 'cds.String');
    addAction(draftPrepare, artifact);

    if (artifact == rootArtifact) {
      // action draftActivate() return <artifact>;
      let draftActivate = createAction('draftActivate', artifactName);
      addAction(draftActivate, artifact);

      // action draftEdit (PreserveChanges: Boolean) return <artifact>;
      let draftEdit = createAction('draftEdit', artifactName, 'PreserveChanges', 'cds.Boolean');
      addAction(draftEdit, artifact);
    }
  }

  // CDXCORE-481
  // (14) If the member is an association whose target has @cds.odata.valuelist annotate it
  // with @Common.ValueList.viaAssociation.
  // This must be done before foreign keys are calculated and the annotations are propagated
  // to them. This will make sure that association and all its foreing keys are annotated with
  // Common.ValueList in the final EDM.
  // Do this only if the association is navigable and the enclosing artifact is 
  // a service member (don't pollute the CSN with unnecessary annotations).
  // TODO: test???
  function addCommonValueListviaAssociation(member, memberName) {
    let vlAnno = '@Common.ValueList.viaAssociation';
    if (isAssociation(member.type, csn)) {
      let navigable = member['@odata.navigable'];
      let targetDef = getCsnDef(member.target);
      if (navigable && targetDef['@cds.odata.valuelist'] && !member[vlAnno]) {
        member[vlAnno] = { '=': memberName };
      }
    }
  }
}

// Return an array of non-abstract service names contained in compacted 'model'
function getServiceNames(model) {
  let result = [];
  forEachDefinition(model, (artifact, artifactName) => {
    if (artifact.kind == 'service' && !artifact.abstract) {
      result.push(artifactName);
    }
  });
  return result;
}

// Rename annotation 'fromName' in 'node' to 'toName' (both names including '@')
function renameAnnotation(node, fromName, toName) {
  let annotation = node && node[fromName];
  // Sanity checks
  if (!fromName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + fromName);
  }
  if (!toName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + toName);
  }
  if (annotation == undefined) {
    throw Error('Annotation ' + fromName + ' not found in ' + JSON.stringify(node));
  }
  delete node[fromName];
  node[toName] = annotation;
}

// some model utilities => TODO: move them to separate file
function isArtifactInSomeService(artName, services) {
  return services.some(serviceName => artName.startsWith(`${serviceName}.`));
}

function getServiceOfArtifact(artName, services) {
  return services.find(serviceName => artName.startsWith(`${serviceName}.`));
}


// Check if an artifact with name 'artName' is part of a 'service'
function isArtifactInService(artName, service) {
  return artName.startsWith(`${service}.`);
}
