const fs = require('fs-extra')
const path = require('path')
const BuildTaskHandler = require('../buildTaskHandler')
const term = require('../../../bin/utils/term')
const { getApplicationName, getHdiServiceName } = require('../../utils/mtaUtil')
const { OUTPUT_MODE_RESULT_ONLY, BUILD_OPTION_OUTPUT_MODE } = require('../constants')

const DEBUG = process.env.DEBUG
const GENERATED_SOURCES_FOLDER = path.join("src", "gen")

const FILE_CONTENT_HDINAMESPACE = {
    "name": "",
    "subfolder": "ignore"
}

const FILE_EXT_CDS = ".cds"
const FILE_EXT_CSV = ".csv"
const FILE_EXT_HDBTABLEDATA = ".hdbtabledata"
const FILE_EXT_HDBCDS = ".hdbcds"

const FILE_NAME_HDICONFIG = ".hdiconfig"
const FILE_NAME_HDINAMESPACE = ".hdinamespace"
const FILE_NAME_PACKAGE_JSON = "package.json"
const FILE_NAME_MANIFEST_YAML = "manifest.yaml"

class HanaModuleBuilder extends BuildTaskHandler {
    constructor(task, buildOptions) {
        super("Hana DB Module Builder", task, buildOptions)
        this._result = {
            dest: this.task.dest,
            hdbcds: []
        }
    }

    async build() {
        const { src, dest } = this.task

        const modelPaths = this._resolveModel()

        this.logger.log(`\n[cds] - building module [${this._stripProjectPaths(src)}] using [${this.name}]`)

        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log("[cds] - no model found, skip build")
            return this._result
        }

        this.logger.log(`[cds] - model: ${this._stripProjectPaths(modelPaths).join(", ")}`)

        await this._compilePersistenceModel(modelPaths, dest)

        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            await this._copyNativeContent(src, dest)
            await this._writeHdiConfig(src, dest)
            await this._writeHdiNamespace(dest)

            if (!this.hasBuildOption("skipPackageJsonGeneration", true)) {
                await this._writePackageJson(src, dest)
            }
            if (!this.hasBuildOption("skipManifestGeneration", true)) {
                await this._writeManifestYaml()
            }

            // Option is set by mtx to original src folder of basemodel which is located under node_modules/_base/<dbDir>/src
            // for the current build. Needed to preserve native hana content of basemodel.
            // TODO - this needs to be replaced once we are implementing the handling hana artefacts of reuse modules
            if (this.task.options.build && this.task.options.build.mtxOriginalSrc) {
                const baseModelDbSrcPath = path.join(this._buildOptions.root, this.task.options.build.mtxOriginalSrc, 'src')
                if (await fs.pathExists(baseModelDbSrcPath)) {
                    const destSrc = path.join(dest, GENERATED_SOURCES_FOLDER)
                    await this._copyNativeContent(baseModelDbSrcPath, destSrc)
                }
            }
        }
        return this._result
    }

    async clean() {
        const srcGenDir = path.join(this.task.src, GENERATED_SOURCES_FOLDER)

        if (!this._isStagingBuild()) {
            return fs.remove(srcGenDir)
        } else {
            return Promise.all([
                fs.remove(srcGenDir), // make sure a gen folder created by an inplace build will be deleted
                super.clean()
            ])
        }
    }

    async _copyNativeContent(src, dest) {
        const dbSrcDir = path.join(src, "src")

        // 1. copy '.csv' files located in 'db/src/**' to '<target>/db/src/**'
        // 2. copy '.csv' files located in 'db' to 'db/src
        await super._copyNativeContent(src, dest, (entry) => {
            const extname = path.extname(entry)
            return (fs.statSync(entry).isDirectory() && path.dirname(entry) !== dest) ||
                (extname !== FILE_EXT_CSV && extname !== FILE_EXT_HDBTABLEDATA && extname !== FILE_EXT_CDS && entry !== this.cds.env.build.outputfile) ||
                ((extname === FILE_EXT_CSV || extname === FILE_EXT_HDBTABLEDATA) && entry.startsWith(dbSrcDir))
        })
        // handle .csv and .hdbtabledata
        const files = BuildTaskHandler._find(src, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return true
            }

            const extname = path.extname(entry)
            return (extname === FILE_EXT_CSV || extname === FILE_EXT_HDBTABLEDATA) && !entry.startsWith(dbSrcDir)
        })
        return Promise.all(files.map((file) => {
            return this.copy(file).to(path.join(dest, GENERATED_SOURCES_FOLDER, path.relative(src, file)))
        }))
    }

    async _compilePersistenceModel(modelPaths, dest) {
        const model = await this.cds.load(modelPaths)
        const promises = []

        // .hdbcds files
        for (let [each, {
            name
        }] of this.cds.compile.to.hana(model)) {
            const relativeDestinationPath = path.join(GENERATED_SOURCES_FOLDER, name + FILE_EXT_HDBCDS)
            this._result.hdbcds.push(relativeDestinationPath)
            const destinationPath = path.join(dest, relativeDestinationPath)
            if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
                promises.push(this.write(each).to(destinationPath))
            }
        }

        await Promise.all(promises)
    }

    async _writePackageJson(src, dest) {
        const packageJson = path.join(src, "package.json")
        const exists = await fs.pathExists(packageJson)

        if (DEBUG && exists) {
            this.logger.log(`[cds] - skip create [${this._stripProjectPaths(packageJson)}], already existing`)
        }
        if (this._isStagingBuild() && !exists) {
            const content = await this._readTemplateAsJson(path.join("db", "hana", FILE_NAME_PACKAGE_JSON))
            if (content && content.scripts && content.scripts.postinstall) {
                // postinstall hook not required in staging build
                delete content.scripts.postinstall
            }

            await this.write(content).to(path.join(dest, FILE_NAME_PACKAGE_JSON))
        }
    }

    async _writeHdiConfig(src, dest) {
        const hdiConfig = path.join(src, "src", ".hdiconfig")
        const exists = await fs.pathExists(hdiConfig)

        if (DEBUG && exists) {
            this.logger.log(`[cds] - skip create [${this._stripProjectPaths(hdiConfig)}], already existing`)
        }
        if (this._isStagingBuild() && !exists) {
            const content = await this._readTemplateAsJson(path.join("db", "hana", "src", FILE_NAME_HDICONFIG))
            await this.write(content).to(path.join(dest, "src", FILE_NAME_HDICONFIG))
        }
    }

    async _writeHdiNamespace(dest) {
        // see issue #64 - add .hdinamespace file to prevent HDI from adding gen/ folder to the namespace.
        return this.write(FILE_CONTENT_HDINAMESPACE).to(path.join(dest, GENERATED_SOURCES_FOLDER, FILE_NAME_HDINAMESPACE))
    }

    async _writeManifestYaml() {
        if (!this._isStagingBuild()) {
            return
        }
        const existsManifestYaml = await this._existsManifestYaml()
        if (existsManifestYaml) {
            if (DEBUG) {
                this.logger.log('[cds] - skip creating [manifest.yaml], already existing')
            }
            return
        }
        const [hdiServiceName, applicationName] = await Promise.all([
            getHdiServiceName(this.buildOptions.root, this.task.src, this.logger),
            getApplicationName(this.buildOptions.root, this.task.src, "hdb", this.logger)
        ])

        const MANIFEST_YAML_CONTENT = `---
applications:
- name: ${applicationName}
  random-route: true
  health-check-type: none
  services:
  - ${hdiServiceName}`

        this.logger.log("Cloud Foundry service binding required for HDI container.")
        this.logger.log("To create a service use CF command")
        this.logger.log("")
        this.logger.log(term.info(`  cf cs hana hdi-shared ${hdiServiceName}`))
        this.logger.log("")

        await this.write(MANIFEST_YAML_CONTENT).to(path.join(this.task.dest, FILE_NAME_MANIFEST_YAML))
    }

    async _existsManifestYaml() {
        return await fs.pathExists(path.join(this.buildOptions.root, FILE_NAME_MANIFEST_YAML)) || await fs.pathExists(path.join(this.task.src, FILE_NAME_MANIFEST_YAML))
    }

    async _readTemplateAsJson(relTemplatePath) {
        const cdsGen = require("@sap/generator-cds")
        const templatePath = path.join(cdsGen.templatePath, relTemplatePath)

        return fs.readJSON(templatePath).catch((error) => {
            this.logger.error(`Failed to read cds generator template [${templatePath}]`)
            return Promise.reject(error)
        })
    }
}
module.exports = HanaModuleBuilder
