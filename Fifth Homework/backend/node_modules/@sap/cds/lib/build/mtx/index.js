const fs = require('fs-extra')
const path = require('path')
const BuildTaskHandler = require('../buildTaskHandler')
const BuildTaskFactory = require('../buildTaskFactory')
const { BUILD_TASK_HANA } = require('../constants')

const FILE_EXT_CSV = ".csv"
const FILE_EXT_HDBTABLEDATA = ".hdbtabledata"
const FILE_EXT_HDBCDS = ".hdbcds"

const FOLDER_SDC = "sdc"
const FOLDER_NODE_MODULES = "node_modules"
const FOLDER_GEN = "gen"

class MtxModuleBuilder extends BuildTaskHandler {
    constructor(task, buildOptions) {
        super("Multitenant Application Builder", task, buildOptions)
    }

    init() {
        if( this.env.build.target === ".") {
            this.task.dest = path.join(this.task.dest, "gen/sdc")
        } else {
            this.task.dest = path.join(this.task.dest, "sdc")
        }
    }

    async build() {
        this.logger.log(`\n[cds] - building multitenant application`)

        const tasks = await new BuildTaskFactory(this.logger, this.cds)._createTasksFromConfig(this.buildOptions.root)
        if (tasks.length === 0) {
            this.logger.log("[cds] - no cds content found, skip build")
            return
        }
        const models = tasks.reduce((acc, task) => {
            if (Array.isArray(task.options.model)) {
                task.options.model.forEach(model => acc.add(model))
            }
            return acc
        }, new Set())

        const modelPaths = this.cds.resolve(Array.from(models))
        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log("[cds] - no model found, skip build")
            return
        }

        this.logger.log(`[cds] - model: ${this._stripProjectPaths(modelPaths).join(", ")}`)

        const csn = await this._compileCsn(modelPaths)
        const bundles = this._collectBundles(csn._sources)
        const {
            folders = ['i18n'], file = 'i18n'
        } = this.cds.env.i18n

        const promises = csn._sources.map(src => {
            if (src.includes(FOLDER_NODE_MODULES)) {
                return this.copy(src).to(path.join(this.task.dest, src.substr(src.indexOf(FOLDER_NODE_MODULES))))
            } else {
                return this.copy(src).to(path.join(this.task.dest, path.relative(this.buildOptions.root, src)))
            }
        })

        if (Object.keys(bundles).length > 0) {
            promises.push(this.write(bundles).to(path.join(this.task.dest, folders[0], file + '.json')))
        }

        //promises.push(this._copyNativeContent(this.task.src, this.task.dest))

        // copying only hdb specific content might be more robust
        const hanaTask = tasks.find(task => task.for === BUILD_TASK_HANA)
        if (hanaTask) {
            const src = path.resolve(this.buildOptions.root, hanaTask.src)
            const dest = path.resolve(this.task.dest, hanaTask.src)
            promises.push(this._copyNativeContent(src, dest))
        } else {
            this.logger.warn('[cds] - no hana db module found, skip copying corresponding artefacts')
        }
        return Promise.all(promises)
    }

    async clean() {
        const srcGenDir = path.join(this.task.src, "sdc")

        if (!this._isStagingBuild()) {
            return fs.remove(srcGenDir)
        } else {
            return Promise.all([
                fs.remove(srcGenDir), // make sure a gen folder created by an inplace build will be deleted
                super.clean()
            ])
        }
    }

    async _copyNativeContent(src, dest) {
        return super._copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                const folderName = path.basename(entry)
                return folderName !== FOLDER_SDC && folderName !== FOLDER_NODE_MODULES && folderName !== FOLDER_GEN
            } else {
                const extname = path.extname(entry)
                return extname === FILE_EXT_CSV || extname === FILE_EXT_HDBTABLEDATA || extname === FILE_EXT_HDBCDS
            }
        })
    }

    async _compileCsn(modelPaths) {
        return require('../../models/cdsv').compile(modelPaths, path.relative(process.cwd(), this.buildOptions.root))
    }

    _collectBundles(sources) {
        // collect effective i18n properties...
        let bundles = {}
        const bundleGenerator = this.cds.localize.bundles4({
            _sources: sources
        })

        if (typeof bundleGenerator === "object" && bundleGenerator.next) {
            for (let [locale, bundle] of bundleGenerator) {
                // fallback bundle has the name ""
                if (typeof locale === 'string') {
                    bundles[locale] = bundle
                }
            }
        }

        // omit bundles in case the fallback bundle is the only existing entry
        const keys = Object.keys(bundles)
        if (keys.length === 1 && keys[0] === "" && Object.keys(bundles[keys[0]]).length === 0) {
            bundles = {}
        }
        return bundles
    }
}
module.exports = MtxModuleBuilder
