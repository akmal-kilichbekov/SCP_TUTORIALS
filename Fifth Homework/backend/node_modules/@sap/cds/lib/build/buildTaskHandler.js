const fs = require('fs-extra')
const path = require('path')
const { BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_DEFAULT, OUTPUT_MODE_RESULT_ONLY } = require('./constants')

class BuildTaskHandler {
    constructor(name, task, buildOptions) {
        task.options = task.options || {}

        this._name = name
        this._task = task
        this._buildOptions = buildOptions || {}
        this._written = []
        this._buildOptions.for = this._buildOptions.for || {}
        this._buildOptions.for[task.for] = this._buildOptions.for[task.for] || {}
        this._buildOptions.outputMode = this._buildOptions.outputMode || OUTPUT_MODE_DEFAULT
    }

    get name() {
        return this._name;
    }
    get logger() {
        return this._logger;
    }
    set logger(logger) {
        this._logger = logger;
    }
    set cds(cds) {
        this._cds = cds;
    }
    get cds() {
        return this._cds
    }
    get env() {
        return this._cds.env
    }
    get task() {
        return this._task
    }
    get buildOptions() {
        return this._buildOptions
    }
    /**
     * Returns the task type specific build option with the given name
     * @param {string} name
     */
    buildOption(name) {
        const taskBuildOptions = this.buildOptions.for[this.task.for]
        return taskBuildOptions && taskBuildOptions[name] ? taskBuildOptions[name] : this.buildOptions[name]
    }
    /**
     * Returns whether a task type specific build option with the given property name has the specified value.
     * If the value is omitted the existence of the given property name is checked.
     * @param {string} name
     * @param {string=} value
     */
    hasBuildOption(name, value) {
        return BuildTaskHandler._hasOptionValue(this.buildOption(name), value)
    }
    /**
     * Returns whether cds env has a property with the specified value.
     * If the value is omitted the existence of the given property name is checked.
     * @param {string} qualifiedName
     * @param {string=} value
     */
    hasCdsEnvOption(qualifiedName, value) {
        return BuildTaskHandler._hasOptionValue(BuildTaskHandler._getOptionValue(this.env, qualifiedName), value)
    }
    get written() {
        return this._written
    }

    /**
     * Called by the framework immediately after this instance has been created.
     * The instance has already been fully initialized.
     */
    init() { }

    /**
     * Called by the framework after {@link #init()}. Handlers may want to perform more elaborate preparation.
     * E.g. caching some pre-calculated data that can be used across multiple build tasks. This kind of data
     * has to be stored in the handler type specific buildOptions section.
     * @returns {boolean} A value 'false' indicates that {@link #prepare()} will not be called for other instances
     * of this handler type.
     * True indicates that {@link #prepare()} will be called for other instances of this of this handler type.
     */
    async prepare() {
        // cancel subsequent prepare calls for other handlers of the same type by default
        return false
    }

    async build() { }

    async clean() {
        if (!this._isStagingBuild()) {
            return Promise.resolve()
        }
        return fs.remove(this.task.dest)
    }

    write(data) {
        return {
            to: async (dest) => {
                if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
                    this._written.push(dest)
                    if (this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_DEFAULT)) {
                        await fs.outputFile(dest, typeof data === "object" ? JSON.stringify(data, null, 2) : data)
                    }
                }
            }
        }
    }

    copy(source) {
        return {
            to: async (dest) => {
                if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
                    this._written.push(dest)
                    if (this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_DEFAULT)) {
                        await fs.copy(source, dest)
                    }
                }
            }
        }
    }
    /**
     * Returns whether the currently executed build represents a staging build or not.
     * A build is referred to as staging build if either the build.target is set to some directory other than '.'
     * or if task.dest is not a sub-directory of the task's source directory (task.src)
     */
    _isStagingBuild() {
        return this.task.src !== (this.task.dest || this.task.src)
    }
    _resolveModel() {
        return this.cds.resolve(this.task.options.model || this.task.src, this.buildOptions)
    }
    async _copyNativeContent(srcDir, destDir, filter) {
        if (!this._isStagingBuild()) {
            return Promise.resolve()
        }
        const targetDir = path.resolve(this.buildOptions.root, this.cds.env.build.target)

        const files = BuildTaskHandler._find(srcDir, (src) => {
            // do not copy files that:
            // - are contained in the 'cds.env.build.target' folder
            // - are contained in this modules 'dest' folder
            // - do not fullfill additional specific filter criteria

            // node_modules folder has to be copied to staging directory
            //const regex = new RegExp("\\" + path.sep + "node_modules\\" + path.sep)

            return (typeof src === "string" && src !== targetDir && src !== destDir /* && !src.match(regex) */ && (!filter || filter.call(this, src)))
        })

        return Promise.all(
            files.map((srcFile) => {
                let relFile = path.relative(srcDir, srcFile)
                let destFile = path.join(destDir, relFile)
                return this.copy(srcFile).to(destFile)
            })
        )
    }
    // Returning the project relative path representation of the given path(s),
    _stripProjectPaths(qualifiedPaths) {
        if (typeof qualifiedPaths === "string") {
            return path.relative(this.buildOptions.root, qualifiedPaths)
        } else if (Array.isArray(qualifiedPaths)) {
            return qualifiedPaths.map(qualifiedPath => path.relative(this.buildOptions.root, qualifiedPath))
        }

        return qualifiedPaths
    }
    static _find(sourceDir, filter) {
        const files = []
        BuildTaskHandler._traverseFileSystem(sourceDir, files, filter)

        return files;
    }
    static _traverseFileSystem(sourceDir, files, filter) {
        fs.readdirSync(sourceDir).map((subDirEntry) => path.join(sourceDir, subDirEntry)).forEach((entry) => {
            var stats = fs.statSync(entry)
            if (stats.isDirectory() && (!filter || filter.call(this, entry))) {
                BuildTaskHandler._traverseFileSystem(entry, files, filter)
            }
            if (stats.isFile() && (!filter || filter.call(this, entry))) {
                files.push(entry)
            }
        })
    }
    static _getOptionValue(optionObject, qualifiedName) {
        return qualifiedName.split('.').reduce((p, n) => p && p[n], optionObject)
    }
    static _hasOptionValue(actual, expected) {
        if (typeof expected === 'undefined') {
            return actual !== undefined
        }
        if (typeof actual === 'undefined') {
            return false
        }
        try {
            return JSON.parse(actual) === JSON.parse(expected)
        } catch (e) {
            // skip
        }
        return actual === expected
    }
}

module.exports = BuildTaskHandler