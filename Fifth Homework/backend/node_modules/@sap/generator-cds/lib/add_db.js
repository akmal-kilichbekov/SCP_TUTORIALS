const path = require('path');

const AddHandler = require('./add');
const Constants = require('./constants');
const FsHelper = require('./helper/fs_helper');
const i18n = require('./i18n/i18n');
const MTAHelper = require('./helper/mta_helper');
const NpmDependenciesHelper = require('./helper/npm_dependencies_helper');



class AddDbHandler extends AddHandler {
    constructor(addCommand) {
        super(addCommand);
    }

    async stageCopyTemplates(moduleFolder, options) {
        this._command.reportProgress(i18n.t(i18n.add_copying_templates, { moduleFolder, moduleType: Constants.MODULE_TYPE_DB }), options.verbose);

        const modulePath = path.join(options.projectRoot, moduleFolder);
        await FsHelper.mkdirp(modulePath);
        if (options.dbTechnology === Constants.DB_TECHNOLOGY_HANA) {
            await FsHelper.copyTemplate('db/hana', modulePath, options);
        }
    }

    async copySamples(moduleFolder, options) {
        const modulePath = path.join(options.projectRoot, moduleFolder);
        await FsHelper.copyTemplate('db/samples', modulePath, {});
    }

    async stagePostProcessing(moduleFolder, options) {
        const yamlPath = path.join(options.projectRoot, 'mta.yaml');
        if (await FsHelper.pathExists(yamlPath)) {
            this._command.reportProgress(i18n.t(i18n.init_creating_mta_file, { yamlPath }), options.verbose);
            await MTAHelper.update(
                moduleFolder,
                yamlPath,
                Constants.MODULE_TYPE_DB,
                options,
                this.logger
            );
        }

        await this._extendGlobalPackageJson(moduleFolder, options);
        await this.extendCdsrcJson(moduleFolder, Constants.TASKS[Constants.MODULE_TYPE_DB][options.dbTechnology], options);
    }

    async _extendGlobalPackageJsonHana(packageJson, options) {
        packageJson.dependencies = packageJson.dependencies || {};
        packageJson.dependencies.hdb = NpmDependenciesHelper.REPLACE_TOKEN;

        const newDependencies = await NpmDependenciesHelper.updateDependencies(packageJson.dependencies, options, this.logger);
        packageJson.dependencies = newDependencies;

        packageJson.cds = packageJson.cds || {};
        packageJson.cds.requires = packageJson.cds.requires || {};

        packageJson.cds.requires[Constants.PRIMARY_DB] = packageJson.cds.requires[Constants.PRIMARY_DB] || {};
        packageJson.cds.requires[Constants.PRIMARY_DB].kind = Constants.DB_TECHNOLOGY_HANA;
        packageJson.cds.requires[Constants.PRIMARY_DB].model = this.getModelFolders(options);
    }

    async _extendGlobalPackageJsonSqlite(packageJson, options) {
        packageJson.devDependencies = packageJson.devDependencies || {};
        packageJson.devDependencies.sqlite3 = NpmDependenciesHelper.REPLACE_TOKEN;

        const newDevDependencies = await NpmDependenciesHelper.updateDependencies(packageJson.devDependencies, options, this.logger);
        packageJson.devDependencies = newDevDependencies;

        packageJson.cds = packageJson.cds || {};
        packageJson.cds.requires = packageJson.cds.requires || {};

        packageJson.cds.requires[Constants.PRIMARY_DB] = packageJson.cds.requires[Constants.PRIMARY_DB] || {};
        packageJson.cds.requires[Constants.PRIMARY_DB].kind = Constants.DB_TECHNOLOGY_SQLITE;
        packageJson.cds.requires[Constants.PRIMARY_DB].model = this.getModelFolders(options);

        packageJson.cds.requires[Constants.PRIMARY_DB].credentials = {
            database: `${options.projectName}.db`
        };
    }

    getModelFolders(options) {
        const result = [];
        for (var moduleType in options.modules) {
            result.push(options.modules[moduleType].folder);
        }
        return result;
    }

    async _extendGlobalPackageJson(moduleFolder, options) { //NOSONAR
        const packageJsonPath = path.join(options.projectRoot, Constants.FILE_NAME_PACKAGE_JSON);

        if (await FsHelper.pathExists(packageJsonPath)) {
            const packageJson = await FsHelper.readJSON(packageJsonPath);

            let packageJsonChanged = false;

            switch (options.dbTechnology) {
                case Constants.DB_TECHNOLOGY_HANA:
                    await this._extendGlobalPackageJsonHana(packageJson, options);
                    packageJsonChanged = true;
                    break;

                case Constants.DB_TECHNOLOGY_SQLITE:
                    await this._extendGlobalPackageJsonSqlite(packageJson, options);
                    packageJsonChanged = true;
                    break;

                default:
                    break;
            }

            packageJson.files = packageJson.files || [];
            if (!packageJson.files.includes(moduleFolder)) {
                packageJson.files.push(moduleFolder);
                packageJsonChanged = true;
            }

            if (moduleFolder !== Constants.DEFAULT_MODULE_FOLDER[Constants.MODULE_TYPE_DB]) {
                packageJson.cds = packageJson.cds || {};
                packageJson.cds.folders = packageJson.cds.folders || {};

                const typeEntry = packageJson.cds.folders[Constants.MODULE_TYPE_DB];
                if (!typeEntry) {
                    packageJson.cds.folders[Constants.MODULE_TYPE_DB] = moduleFolder;
                } else if (typeEntry instanceof String || typeof typeEntry === 'string') {
                    packageJson.cds.folders[Constants.MODULE_TYPE_DB] = [typeEntry, moduleFolder];
                } else if (Array.isArray(typeEntry)) {
                    packageJson.cds.folders[Constants.MODULE_TYPE_DB].push(moduleFolder);
                }

                packageJsonChanged = true;
            }

            if (packageJsonChanged) {
                await FsHelper.writeJSON(packageJsonPath, packageJson);
            }
        }
    }
}

module.exports = AddDbHandler;
