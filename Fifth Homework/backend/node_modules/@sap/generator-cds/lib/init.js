const path = require('path');

const AddDbHandler = require('./add_db');
const AddSrvHandler = require('./add_srv');
const Command = require('./command');
const Constants = require('./constants');

const ExecHelper = require('./helper/exec_helper');
const FsHelper = require('./helper/fs_helper');
const i18n = require('./i18n/i18n');


const CONFIG = Object.freeze({
    dbTechnology: {
        description: `Databse technology, valid values are 'hana' and 'sqlite'`,
        default: Constants.DB_TECHNOLOGY_SQLITE,
        regex: new RegExp(Constants.REGEX_DB_TECHNOLOGY)
    },
    insecure: {
        default: false
    },
    javaPackage: {
        default: 'sample',
    },
    modules: {
        default: '',
        regex: new RegExp(Constants.REGEX_MODULES)
    },
    mta: {
        default: false
    },
    odataVersion: {
        default: 'odatav2',
        regex: new RegExp(Constants.REGEX_ODATA_VERSION)
    },
    skipInstall: {
        default: false
    },
    skipSampleModels: {
        default: false
    },
    srvMemory: {
        default: '512M',
        regex: /^[1-9]\d*\w?$/
    },
    srvTechnology: {
        default: 'nodejs',
        regex: new RegExp(Constants.REGEX_SRV_TECHNOLOGY)
    },

    // deprecated, for backward compatibility
    moduleType: {
        default: '',
        deprecated: true,
        regex: new RegExp(Constants.REGEX_MODULE_TYPE)
    }
});

class InitCommand extends Command {
    constructor() {
        super(CONFIG);
    }

    get options() {
        return this._options;
    }

    async run(args, options, cdsEnv, logger) {
        await super.run(args, options, cdsEnv, logger);

        this._options.projectRoot = path.resolve(this._options.destination);
        this._options.projectName = path.basename(this._options.projectRoot);

        this._handleModules(this._options);

        await this.execute(this._options.projectRoot, this._options);

        await this.finalize();

        this.reportProgress(i18n.init_finished_successfully, !options.quiet);
    }

    _handleModules(options) {
        if (options.modules) {
            const modules = options.modules.split(',');

            const newModules = {};
            for (let currentModule of modules) {
                const segments = currentModule.split(':');
                let moduleType;
                let moduleFolder;
                if (segments.length === 2) {
                    moduleType = segments[1];
                    moduleFolder = segments[0];

                    if (!options.force) {
                        this.validateDestination(moduleFolder);
                    }
                } else {
                    moduleType = currentModule;
                    moduleFolder = Constants.DEFAULT_MODULE_FOLDER[currentModule];
                }

                if (newModules[moduleType]) {
                    // module type already declared
                    throw new Error(i18n.t(i18n.init_duplicate_module_type, {
                        newModuleFolder: moduleFolder,
                        ...newModules[moduleType]
                    }));
                }

                newModules[moduleType] = {
                    type: moduleType,
                    folder: moduleFolder
                };
            }
            options.modules = newModules;

        } else {
            options.modules = {};
        }
    }

    async execute(destPath, options) {
        await this.checkPrecondition(destPath, options);

        if (!options.quiet) {
            const message = (options.reinit
                ? i18n.t(i18n.init_reinitializing_project, { destination: options.projectName })
                : i18n.t(i18n.init_initializing_project, { destination: options.projectName }));
            this.reportProgress(message, true);
        }

        await this._removeEmptyPackageJson(destPath);

        // copy all standard project files
        await FsHelper.copyTemplate('project/common', destPath, options);

        // mta template
        if (options.mta) {
            await FsHelper.copyTemplate('project/mta', destPath, options);
        }

        // assume vs code as ide if ran from command line
        if (!process.env[Constants.ENV_KEY_CDS_IDE]) {
            await FsHelper.copyTemplate('project/vscode', destPath, options);
        }

        // skip samples if not both srv and db are present
        const dbModule = options.modules[Constants.MODULE_TYPE_DB];
        const srvModule = options.modules[Constants.MODULE_TYPE_SRV];
        const copySamples = !options.skipSampleModels && dbModule && srvModule;

        // handle all sub modules
        for (let moduleType of Object.keys(options.modules)) {
            const moduleFolder = options.modules[moduleType].folder;
            const handler = this._getAddHandler(moduleType);
            await handler.stageCopyTemplates(moduleFolder, options);
            await handler.stagePostProcessing(moduleFolder, options);

            // ... and the samples
            if (copySamples) {
                await handler.copySamples(moduleFolder, options);
            }
        }

        await this._stagePostProcessing(options);
    }

    // remove empty package.json and let generator copy template
    async _removeEmptyPackageJson(destPath) {
        const packageJsonPath = path.join(destPath, Constants.FILE_NAME_PACKAGE_JSON);
        if (await FsHelper.pathExists(packageJsonPath)) {
            const packageJson = await FsHelper.readJSON(packageJsonPath);
            if (Object.keys(packageJson).length === 0) {
                await FsHelper.remove(packageJsonPath);
            }
        }
    }

    _getAddHandler(moduleType) {
        switch (moduleType) {
            case Constants.MODULE_TYPE_DB:
                if (!this._dbAddHandler) {
                    this._dbAddHandler = new AddDbHandler(this);
                }
                return this._dbAddHandler;

            case Constants.MODULE_TYPE_SRV:
                if (!this._srvAddHandler) {
                    this._srvAddHandler = new AddSrvHandler(this);
                }
                return this._srvAddHandler;

            default:
                throw new Error(`Unknown type ${moduleType}`);
        }
    }

    async checkPrecondition(destPath, options) {

        if (options.force && !options.quiet) {
            this.logger.warn(i18n.init_using_force);
        }

        const absoluteCwd = path.resolve('.');
        if (!destPath.startsWith(absoluteCwd)) {
            throw new Error(i18n.init_invalid_project_path);
        }

        // with srv java use db hana, else print warning
        if (options.modules[Constants.MODULE_TYPE_SRV]
            && options.modules[Constants.MODULE_TYPE_DB]
            && options.srvTechnology === Constants.SRV_TECHNOLOGY_JAVA
            && options.dbTechnology !== Constants.DB_TECHNOLOGY_HANA) {
            this.reportWarning(i18n.init_srv_java_and_db_hana, !options.quiet);
        }

        if (!options.force) {
            this.validateDestination(destPath);
        }

        if (await FsHelper.pathExists(destPath)) {
            const folderContent = await FsHelper.readdir(destPath);
            if (folderContent.length > 0) {
                options.reinit = true;
            }
        }

        await this._checkModulesPreconditions(options);
    }

    async _checkModulesPreconditions(options) {
        // handle all sub modules
        for (let moduleType of Object.keys(options.modules)) {
            const moduleFolder = options.modules[moduleType].folder;
            const handler = this._getAddHandler(moduleType);
            await handler.checkPrecondition(moduleFolder, options);
        }
    }

    async _stagePostProcessing(options) {
        // root config file processing
        const packageJsonPath = path.join(options.projectRoot, Constants.FILE_NAME_PACKAGE_JSON);
        this.reportProgress(i18n.t(i18n.init_updating_dependencies, { packageJsonPath }), options.verbose);
        await this.updateDependencies(packageJsonPath, options);

        if (!options.skipInstall) {
            this.reportProgress(
                i18n.init_running_npm_install,
                options.verbose
            );
            const npmInstallCmd = [
                'npm',
                'install',
                '--no-package-lock',
                '--no-shrinkwrap'
            ];

            if (options.debug) {
                npmInstallCmd.push('-dd');
            }

            await ExecHelper.spawnCommand(npmInstallCmd, options.projectRoot, options, this.logger);
        }
    }
}

module.exports = InitCommand;
